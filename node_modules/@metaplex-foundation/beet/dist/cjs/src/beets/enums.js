"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enumsTypeMap = exports.dataEnum = exports.uniformDataEnum = exports.fixedScalarEnum = void 0;
const types_1 = require("../types");
const numbers_1 = require("./numbers");
const assert_1 = require("assert");
const struct_1 = require("../struct");
const struct_fixable_1 = require("../struct.fixable");
const unit_1 = require("./unit");
// -----------------
// Fixed Scalar Enum
// -----------------
function resolveEnumVariant(value, isNumVariant) {
    return (isNumVariant ? `${value}` : value);
}
/**
 * De/serializer for enums with up to 255 less variants which have no data.
 *
 * @param enumType type of enum to process, i.e. Color or Direction
 *
 * @category beet/enum
 */
function fixedScalarEnum(enumType) {
    const keys = Object.keys(enumType);
    return {
        write(buf, offset, value) {
            const isNumVariant = typeof value === 'number';
            const variantKey = resolveEnumVariant(value, isNumVariant);
            if (!keys.includes(variantKey)) {
                assert_1.strict.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);
            }
            if (isNumVariant) {
                numbers_1.u8.write(buf, offset, value);
            }
            else {
                const enumValue = enumType[variantKey];
                numbers_1.u8.write(buf, offset, enumValue);
            }
        },
        read(buf, offset) {
            const value = numbers_1.u8.read(buf, offset);
            const isNumVariant = typeof value === 'number';
            const variantKey = resolveEnumVariant(value, isNumVariant);
            if (!keys.includes(variantKey)) {
                assert_1.strict.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);
            }
            return (isNumVariant ? value : enumType[variantKey]);
        },
        byteSize: numbers_1.u8.byteSize,
        description: 'Enum',
    };
}
exports.fixedScalarEnum = fixedScalarEnum;
/**
 * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.
 * The main difference to a Rust enum is that the type of data has to be the
 * same for all enum variants.
 *
 * @template T inner enum data type
 *
 * @param inner the De/Serializer for the data type
 *
 * @category beet/enum
 */
function uniformDataEnum(inner) {
    return {
        write: function (buf, offset, value) {
            numbers_1.u8.write(buf, offset, value.kind);
            inner.write(buf, offset + 1, value.data);
        },
        read: function (buf, offset) {
            const kind = numbers_1.u8.read(buf, offset);
            const data = inner.read(buf, offset + 1);
            return { kind, data };
        },
        byteSize: 1 + inner.byteSize,
        description: `UniformDataEnum<${inner.description}>`,
    };
}
exports.uniformDataEnum = uniformDataEnum;
function enumDataVariantBeet(inner, discriminant, kind) {
    return {
        write(buf, offset, value) {
            numbers_1.u8.write(buf, offset, discriminant);
            inner.write(buf, offset + numbers_1.u8.byteSize, value);
        },
        read(buf, offset) {
            const val = inner.read(buf, offset + numbers_1.u8.byteSize);
            return { __kind: kind, ...val };
        },
        byteSize: inner.byteSize + numbers_1.u8.byteSize,
        description: `EnumData<${inner.description}>`,
    };
}
/**
 * De/serializes Data Enums.
 * They are represented as a discriminated unions in TypeScript.
 *
 * NOTE: only structs, i.e. {@link BeetArgsStruct} and
 * {@link FixableBeetArgsStruct} are supported as the data of each enum variant.
 *
 * ## Example
 *
 * ```ts
 * type Simple = {
 *   First: { n1: number }
 *   Second: { n2: number }
 * }
 *
 * const beet = dataEnum<Simple>([
 *   ['First', new BeetArgsStruct<Simple['First']>([['n1', u32]])],
 *   ['Second', new BeetArgsStruct<Simple['Second']>([['n2', u32]])],
 * ])
 * ```
 *
 * @category beet/enum
 * @param variants an array of {@link DataEnumBeet}s each a tuple of `[ kind, data ]`
 */
function dataEnum(variants) {
    for (const [_, beet] of variants) {
        (0, assert_1.strict)((0, struct_1.isBeetStruct)(beet) ||
            (0, struct_fixable_1.isFixableBeetStruct)(beet) ||
            // scalar variant
            beet === unit_1.unit, 'dataEnum: variants must be a data beet struct or a scalar unit');
    }
    return {
        toFixedFromData(buf, offset) {
            const discriminant = numbers_1.u8.read(buf, offset);
            const variant = variants[discriminant];
            (0, assert_1.strict)(variant != null, `Discriminant ${discriminant} out of range for ${variants.length} variants`);
            const [__kind, dataBeet] = variant;
            const fixed = (0, types_1.isFixedSizeBeet)(dataBeet)
                ? dataBeet
                : dataBeet.toFixedFromData(buf, offset + 1);
            return enumDataVariantBeet(fixed, discriminant, __kind);
        },
        toFixedFromValue(val) {
            if (val.__kind == null) {
                const keys = Object.keys(val).join(', ');
                const validKinds = variants.map(([__kind]) => __kind).join(', ');
                assert_1.strict.fail(`Value with fields [ ${keys} ] is missing __kind, ` +
                    `which needs to be set to one of [ ${validKinds} ]`);
            }
            const discriminant = variants.findIndex(([__kind]) => __kind === val.__kind);
            if (discriminant < 0) {
                const validKinds = variants.map(([__kind]) => __kind).join(', ');
                assert_1.strict.fail(`${val.__kind} is not a valid kind, needs to be one of [ ${validKinds} ]`);
            }
            const variant = variants[discriminant];
            const { __kind, ...dataValue } = val;
            const [__variantKind, dataBeet] = variant;
            const fixed = (0, types_1.isFixedSizeBeet)(dataBeet)
                ? dataBeet
                : dataBeet.toFixedFromValue(dataValue);
            return enumDataVariantBeet(fixed, discriminant, __variantKind);
        },
        description: `DataEnum<${variants.length} variants>`,
    };
}
exports.dataEnum = dataEnum;
/**
 * Maps composite beet exports to metadata which describes in which package it
 * is defined as well as which TypeScript type is used to represent the
 * deserialized value in JavaScript.
 *
 * @category TypeDefinition
 */
exports.enumsTypeMap = {
    fixedScalarEnum: {
        beet: 'fixedScalarEnum',
        isFixable: false,
        sourcePack: types_1.BEET_PACKAGE,
        ts: '<TypeName>',
        arg: types_1.BEET_TYPE_ARG_INNER,
        pack: types_1.BEET_PACKAGE,
    },
    dataEnum: {
        beet: 'dataEnum',
        isFixable: false,
        sourcePack: types_1.BEET_PACKAGE,
        ts: 'DataEnum<Kind, Inner>',
        arg: types_1.BEET_TYPE_ARG_INNER,
        pack: types_1.BEET_PACKAGE,
    },
};
//# sourceMappingURL=enums.js.map