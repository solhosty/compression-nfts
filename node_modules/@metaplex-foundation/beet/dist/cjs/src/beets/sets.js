"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setsTypeMap = exports.set = void 0;
const types_1 = require("../types");
const numbers_1 = require("./numbers");
const utils_1 = require("../utils");
const assert_1 = require("assert");
/**
 * De/Serializes a set with a specific number of keys of type {@link K}.
 *
 * NOTE: that it is not exported as no fixed size set exists but will have to
 * be derived from data or value instead.
 *
 * @template K type of key elements held in the set
 *
 * @param keyElement the De/Serializers for the key element types
 * @param len amount of entries in the set
 *
 * @category beet/composite
 * @private
 */
function fixedSizeSet(keyElement, fixedElements, len) {
    const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);
    function determineSizes() {
        if (keyElementFixed) {
            const elementByteSize = keyElement.byteSize;
            return {
                elementByteSize,
                byteSize: 4 + len * elementByteSize,
            };
        }
        else {
            let keysByteSize = 0;
            for (const k of fixedElements.values()) {
                keysByteSize += k.byteSize;
            }
            const elementByteSize = Math.ceil(keysByteSize / len);
            return {
                elementByteSize,
                byteSize: 4 + keysByteSize,
            };
        }
    }
    const { elementByteSize, byteSize } = determineSizes();
    return {
        write: function (buf, offset, set) {
            // Write the values first and then the size as it comes clear while we do the former
            let cursor = offset + 4;
            let size = 0;
            for (const k of set.keys()) {
                let fixedKey = keyElementFixed ? keyElement : null;
                if (fixedKey == null) {
                    // When we write the value we know the key and an just pull the
                    // matching fixed beet for key from the provided set which is
                    // faster than fixing it by value
                    const el = fixedElements.get(k);
                    (0, assert_1.strict)(el != null, `Should be able to find beet el for ${(0, utils_1.stringify)(k)}, but could not`);
                    fixedKey !== null && fixedKey !== void 0 ? fixedKey : (fixedKey = el);
                }
                fixedKey.write(buf, cursor, k);
                cursor += fixedKey.byteSize;
                size++;
            }
            numbers_1.u32.write(buf, offset, size);
            assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);
        },
        read: function (buf, offset) {
            const size = numbers_1.u32.read(buf, offset);
            assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);
            let cursor = offset + 4;
            const set = new Set();
            for (let i = 0; i < size; i++) {
                // When we read the value from a buffer we don't know the key we're
                // reading yet and thus cannot use the provided set of fixed
                // de/serializers.
                // Therefore we obtain it by fixing it by data instead.
                const fixedKey = keyElementFixed
                    ? keyElement
                    : keyElement.toFixedFromData(buf, cursor);
                const k = fixedKey.read(buf, cursor);
                cursor += fixedKey.byteSize;
                set.add(k);
            }
            return set;
        },
        elementByteSize,
        byteSize,
        length: len,
        lenPrefixByteSize: 4,
        description: `Set<${keyElement.description}>`,
    };
}
/**
 * De/Serializes a set with a specific number of keys of type {@link K}
 *
 * @template K type of key elements held in the set
 *
 * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types
 *
 * @category beet/composite
 */
function set(keyElement) {
    const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);
    return {
        toFixedFromData(buf, offset) {
            const len = numbers_1.u32.read(buf, offset);
            let cursor = offset + 4;
            // Shortcut for the case that both key and value are fixed size beets
            if (keyIsFixed) {
                return fixedSizeSet(keyElement, new Map(), len);
            }
            // If key is not fixed size beet we need to determine the fixed versions and add them to a set by key
            const fixedBeets = new Map();
            for (let i = 0; i < len; i++) {
                const keyFixed = keyIsFixed
                    ? keyElement
                    : keyElement.toFixedFromData(buf, cursor);
                const key = keyFixed.read(buf, cursor);
                cursor += keyFixed.byteSize;
                fixedBeets.set(key, keyFixed);
            }
            return fixedSizeSet(keyElement, fixedBeets, len);
        },
        toFixedFromValue(setVal) {
            const len = setVal.size;
            // As above shortcut for the optimal case and build a set for all others
            if (keyIsFixed) {
                return fixedSizeSet(keyElement, new Map(), len);
            }
            const fixedBeets = new Map();
            for (const k of setVal) {
                const keyFixed = keyIsFixed
                    ? keyElement
                    : keyElement.toFixedFromValue(k);
                fixedBeets.set(k, keyFixed);
            }
            return fixedSizeSet(keyElement, fixedBeets, len);
        },
        description: `FixableSet<${keyElement.description}>`,
    };
}
exports.set = set;
/**
 * Sets sets beet exports to metadata which describes in which package it
 * is defined as well as which TypeScript type is used to represent the
 * deserialized value in JavaScript.
 *
 * @category TypeDefinition
 */
exports.setsTypeMap = {
    Set: {
        beet: 'set',
        isFixable: true,
        sourcePack: types_1.BEET_PACKAGE,
        ts: 'Set',
    },
};
//# sourceMappingURL=sets.js.map