import { Connection, Keypair, PublicKey, Signer, TransactionInstruction } from '@solana/web3.js';
import BN from 'bn.js';
import Decimal from 'decimal.js';
import { Base, ComputeBudgetConfig, InnerTransaction, InstructionType, TokenAccount, TxVersion } from '../base';
import { ApiAmmV3PoolsItem, ApiAmmV3PoolsItemStatistics } from '../baseInfo';
import { Currency, CurrencyAmount, Percent, Price, Token, TokenAmount } from '../entity';
import { TickArray } from './utils/tick';
export interface AmmV3ConfigInfo {
    id: PublicKey;
    index: number;
    protocolFeeRate: number;
    tradeFeeRate: number;
    tickSpacing: number;
    fundFeeRate: number;
    fundOwner: string;
    description: string;
}
export interface AmmV3PoolRewardLayoutInfo {
    rewardState: number;
    openTime: BN;
    endTime: BN;
    lastUpdateTime: BN;
    emissionsPerSecondX64: BN;
    rewardTotalEmissioned: BN;
    rewardClaimed: BN;
    tokenMint: PublicKey;
    tokenVault: PublicKey;
    creator: PublicKey;
    rewardGrowthGlobalX64: BN;
}
export interface AmmV3PoolRewardInfo {
    rewardState: number;
    openTime: BN;
    endTime: BN;
    lastUpdateTime: BN;
    emissionsPerSecondX64: BN;
    rewardTotalEmissioned: BN;
    rewardClaimed: BN;
    tokenMint: PublicKey;
    tokenVault: PublicKey;
    creator: PublicKey;
    rewardGrowthGlobalX64: BN;
    perSecond: Decimal;
    remainingRewards: undefined | BN;
}
export interface AmmV3PoolInfo {
    id: PublicKey;
    mintA: {
        mint: PublicKey;
        vault: PublicKey;
        decimals: number;
    };
    mintB: {
        mint: PublicKey;
        vault: PublicKey;
        decimals: number;
    };
    ammConfig: AmmV3ConfigInfo;
    observationId: PublicKey;
    creator: PublicKey;
    programId: PublicKey;
    version: 6;
    tickSpacing: number;
    liquidity: BN;
    sqrtPriceX64: BN;
    currentPrice: Decimal;
    tickCurrent: number;
    observationIndex: number;
    observationUpdateDuration: number;
    feeGrowthGlobalX64A: BN;
    feeGrowthGlobalX64B: BN;
    protocolFeesTokenA: BN;
    protocolFeesTokenB: BN;
    swapInAmountTokenA: BN;
    swapOutAmountTokenB: BN;
    swapInAmountTokenB: BN;
    swapOutAmountTokenA: BN;
    tickArrayBitmap: BN[];
    rewardInfos: AmmV3PoolRewardInfo[];
    day: ApiAmmV3PoolsItemStatistics;
    week: ApiAmmV3PoolsItemStatistics;
    month: ApiAmmV3PoolsItemStatistics;
    tvl: number;
    lookupTableAccount: PublicKey;
    startTime: number;
}
export interface AmmV3PoolPersonalPosition {
    poolId: PublicKey;
    nftMint: PublicKey;
    priceLower: Decimal;
    priceUpper: Decimal;
    amountA: BN;
    amountB: BN;
    tickLower: number;
    tickUpper: number;
    liquidity: BN;
    feeGrowthInsideLastX64A: BN;
    feeGrowthInsideLastX64B: BN;
    tokenFeesOwedA: BN;
    tokenFeesOwedB: BN;
    rewardInfos: {
        growthInsideLastX64: BN;
        rewardAmountOwed: BN;
        pendingReward: BN;
    }[];
    leverage: number;
    tokenFeeAmountA: BN;
    tokenFeeAmountB: BN;
}
export interface MintInfo {
    mint: PublicKey;
    decimals: number;
}
export interface ReturnTypeGetLiquidityAmountOutFromAmountIn {
    liquidity: BN;
    amountSlippageA: BN;
    amountSlippageB: BN;
    amountA: BN;
    amountB: BN;
}
export interface ReturnTypeGetAmountsFromLiquidity {
    amountSlippageA: BN;
    amountSlippageB: BN;
}
export interface ReturnTypeGetPriceAndTick {
    tick: number;
    price: Decimal;
}
export interface ReturnTypeGetTickPrice {
    tick: number;
    price: Decimal;
    tickSqrtPriceX64: BN;
}
export interface ReturnTypeComputeAmountOutFormat {
    amountOut: CurrencyAmount;
    minAmountOut: CurrencyAmount;
    currentPrice: Price;
    executionPrice: Price;
    priceImpact: Percent;
    fee: CurrencyAmount;
    remainingAccounts: PublicKey[];
}
export interface ReturnTypeComputeAmountOut {
    amountOut: BN;
    minAmountOut: BN;
    currentPrice: Decimal;
    executionPrice: Decimal;
    priceImpact: Percent;
    fee: BN;
    remainingAccounts: PublicKey[];
}
export interface ReturnTypeComputeAmountOutBaseOut {
    amountIn: BN;
    maxAmountIn: BN;
    currentPrice: Decimal;
    executionPrice: Decimal;
    priceImpact: Percent;
    fee: BN;
    remainingAccounts: PublicKey[];
}
export interface ReturnTypeFetchMultiplePoolInfos {
    [id: string]: {
        state: AmmV3PoolInfo;
        positionAccount?: AmmV3PoolPersonalPosition[] | undefined;
    };
}
export interface ReturnTypeFetchMultiplePoolTickArrays {
    [poolId: string]: {
        [key: string]: TickArray;
    };
}
export declare class AmmV3 extends Base {
    static makeMockPoolInfo({ programId, mint1, mint2, ammConfig, createPoolInstructionSimpleAddress, initialPrice, startTime, owner }: {
        programId: PublicKey;
        mint1: MintInfo;
        mint2: MintInfo;
        ammConfig: AmmV3ConfigInfo;
        createPoolInstructionSimpleAddress: {
            observationId: PublicKey;
            poolId: PublicKey;
            mintAVault: PublicKey;
            mintBVault: PublicKey;
            mintA: PublicKey;
            mintB: PublicKey;
        };
        initialPrice: Decimal;
        startTime: BN;
        owner: PublicKey;
    }): AmmV3PoolInfo;
    static makeCreatePoolInstructionSimple({ connection, programId, owner, mint1, mint2, ammConfig, initialPrice, startTime, computeBudgetConfig }: {
        connection: Connection;
        programId: PublicKey;
        owner: PublicKey;
        mint1: MintInfo;
        mint2: MintInfo;
        ammConfig: AmmV3ConfigInfo;
        initialPrice: Decimal;
        startTime: BN;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {
            mintA: PublicKey;
            mintB: PublicKey;
            observationId: PublicKey;
            poolId: PublicKey;
            mintAVault: PublicKey;
            mintBVault: PublicKey;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Keypair[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeOpenPositionInstructionSimple({ connection, poolInfo, ownerInfo, tickLower, tickUpper, liquidity, slippage, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        tickLower: number;
        tickUpper: number;
        liquidity: BN;
        slippage: number;
        associatedOnly?: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {
            nftMint: PublicKey;
            tickArrayLower: PublicKey;
            tickArrayUpper: PublicKey;
            positionNftAccount: PublicKey;
            metadataAccount: PublicKey;
            personalPosition: PublicKey;
            protocolPosition: PublicKey;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeIncreaseLiquidityInstructionSimple({ connection, poolInfo, ownerPosition, ownerInfo, liquidity, slippage, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        liquidity: BN;
        slippage: number;
        associatedOnly?: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {
            tickArrayLower: PublicKey;
            tickArrayUpper: PublicKey;
            positionNftAccount: PublicKey;
            personalPosition: PublicKey;
            protocolPosition: PublicKey;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeDecreaseLiquidityInstructionSimple({ connection, poolInfo, ownerPosition, ownerInfo, liquidity, amountMinA, amountMinB, slippage, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
            closePosition?: boolean;
        };
        liquidity: BN;
        amountMinA?: BN;
        amountMinB?: BN;
        slippage?: number;
        associatedOnly?: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {
            tickArrayLower: PublicKey;
            tickArrayUpper: PublicKey;
            positionNftAccount: PublicKey;
            personalPosition: PublicKey;
            protocolPosition: PublicKey;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeSwapBaseInInstructionSimple({ connection, poolInfo, ownerInfo, inputMint, amountIn, amountOutMin, priceLimit, remainingAccounts, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        inputMint: PublicKey;
        amountIn: BN;
        amountOutMin: BN;
        priceLimit?: Decimal;
        remainingAccounts: PublicKey[];
        associatedOnly?: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {};
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: any[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeSwapBaseOutInstructionSimple({ connection, poolInfo, ownerInfo, outputMint, amountOut, amountInMax, priceLimit, remainingAccounts, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        outputMint: PublicKey;
        amountOut: BN;
        amountInMax: BN;
        priceLimit?: Decimal;
        remainingAccounts: PublicKey[];
        associatedOnly?: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {};
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: any[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeCLosePositionInstructionSimple({ poolInfo, ownerPosition, ownerInfo }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
        };
    }): {
        address: {
            positionNftAccount: PublicKey;
            personalPosition: PublicKey;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: any[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    };
    static makeInitRewardInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfo, chainTime, associatedOnly }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        };
        chainTime: number;
        associatedOnly?: boolean;
    }): Promise<{
        address: {
            poolRewardVault: PublicKey;
            operationId: PublicKey;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeInitRewardsInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfos, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfos: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        }[];
        associatedOnly?: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {};
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeSetRewardInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfo, chainTime, associatedOnly, }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        };
        chainTime: number;
        associatedOnly?: boolean;
    }): Promise<{
        address: {
            rewardVault: any;
            operationId: PublicKey;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeSetRewardsInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfos, chainTime, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfos: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        }[];
        chainTime: number;
        associatedOnly?: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {};
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeCollectRewardInstructionSimple({ connection, poolInfo, ownerInfo, rewardMint, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardMint: PublicKey;
        associatedOnly: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {
            rewardVault: any;
        };
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeCollectRewardsInstructionSimple({ connection, poolInfo, ownerInfo, rewardMints, associatedOnly, computeBudgetConfig }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardMints: PublicKey[];
        associatedOnly: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {};
        innerTransactions: {
            instructions: TransactionInstruction[];
            signers: Signer[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        }[];
    }>;
    static makeHarvestAllRewardInstructionSimple({ connection, fetchPoolInfos, ownerInfo, associatedOnly }: {
        connection: Connection;
        fetchPoolInfos: ReturnTypeFetchMultiplePoolInfos;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        associatedOnly?: boolean;
    }): Promise<{
        address: {};
        innerTransactions: any[];
    }>;
    static makeCreatePoolInstructions({ connection, programId, owner, mintA, mintB, ammConfigId, initialPriceX64, startTime, }: {
        connection: Connection;
        programId: PublicKey;
        owner: PublicKey;
        mintA: MintInfo;
        mintB: MintInfo;
        ammConfigId: PublicKey;
        initialPriceX64: BN;
        startTime: BN;
    }): Promise<{
        address: {
            observationId: PublicKey;
            poolId: PublicKey;
            mintAVault: PublicKey;
            mintBVault: PublicKey;
        };
        innerTransaction: {
            instructions: TransactionInstruction[];
            signers: Keypair[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        };
    }>;
    static makeOpenPositionInstructions({ poolInfo, ownerInfo, tickLower, tickUpper, liquidity, amountSlippageA, amountSlippageB }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
        };
        tickLower: number;
        tickUpper: number;
        liquidity: BN;
        amountSlippageA: BN;
        amountSlippageB: BN;
    }): {
        address: {
            nftMint: PublicKey;
            tickArrayLower: PublicKey;
            tickArrayUpper: PublicKey;
            positionNftAccount: PublicKey;
            metadataAccount: PublicKey;
            personalPosition: PublicKey;
            protocolPosition: PublicKey;
        };
        innerTransaction: InnerTransaction;
    };
    static makeIncreaseLiquidityInstructions({ poolInfo, ownerPosition, ownerInfo, liquidity, amountSlippageA, amountSlippageB }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
        };
        liquidity: BN;
        amountSlippageA: BN;
        amountSlippageB: BN;
    }): {
        address: {
            tickArrayLower: PublicKey;
            tickArrayUpper: PublicKey;
            positionNftAccount: PublicKey;
            personalPosition: PublicKey;
            protocolPosition: PublicKey;
        };
        innerTransaction: InnerTransaction;
    };
    static makeDecreaseLiquidityInstructions({ poolInfo, ownerPosition, ownerInfo, liquidity, amountMinA, amountMinB }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
            rewardAccounts: PublicKey[];
        };
        liquidity: BN;
        amountMinA: BN;
        amountMinB: BN;
    }): {
        address: {
            tickArrayLower: PublicKey;
            tickArrayUpper: PublicKey;
            positionNftAccount: PublicKey;
            personalPosition: PublicKey;
            protocolPosition: PublicKey;
        };
        innerTransaction: InnerTransaction;
    };
    static makeClosePositionInstructions({ poolInfo, ownerInfo, ownerPosition }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
        };
    }): {
        address: {
            positionNftAccount: PublicKey;
            personalPosition: PublicKey;
        };
        innerTransaction: {
            instructions: TransactionInstruction[];
            signers: any[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        };
    };
    static makeSwapBaseInInstructions({ poolInfo, ownerInfo, inputMint, amountIn, amountOutMin, sqrtPriceLimitX64, remainingAccounts }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
        };
        inputMint: PublicKey;
        amountIn: BN;
        amountOutMin: BN;
        sqrtPriceLimitX64: BN;
        remainingAccounts: PublicKey[];
    }): {
        address: {};
        innerTransaction: {
            instructions: TransactionInstruction[];
            signers: any[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        };
    };
    static makeSwapBaseOutInstructions({ poolInfo, ownerInfo, outputMint, amountOut, amountInMax, sqrtPriceLimitX64, remainingAccounts }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
        };
        outputMint: PublicKey;
        amountOut: BN;
        amountInMax: BN;
        sqrtPriceLimitX64: BN;
        remainingAccounts: PublicKey[];
    }): {
        address: {};
        innerTransaction: {
            instructions: TransactionInstruction[];
            signers: any[];
            lookupTableAddress: PublicKey[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        };
    };
    static makeInitRewardInstructions({ poolInfo, ownerInfo, rewardInfo }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccount: PublicKey;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            emissionsPerSecondX64: BN;
        };
    }): {
        address: {
            poolRewardVault: PublicKey;
            operationId: PublicKey;
        };
        innerTransaction: InnerTransaction;
    };
    static makeSetRewardInstructions({ poolInfo, ownerInfo, rewardInfo }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccount: PublicKey;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            emissionsPerSecondX64: BN;
        };
    }): {
        address: {
            rewardVault: any;
            operationId: PublicKey;
        };
        innerTransaction: InnerTransaction;
    };
    static makeCollectRewardInstructions({ poolInfo, ownerInfo, rewardMint }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccount: PublicKey;
        };
        rewardMint: PublicKey;
    }): {
        address: {
            rewardVault: any;
        };
        innerTransaction: InnerTransaction;
    };
    static getLiquidityAmountOutFromAmountIn({ poolInfo, inputA, tickLower, tickUpper, amount, slippage, add }: {
        poolInfo: AmmV3PoolInfo;
        inputA: boolean;
        tickLower: number;
        tickUpper: number;
        amount: BN;
        slippage: number;
        add: boolean;
    }): ReturnTypeGetLiquidityAmountOutFromAmountIn;
    static getLiquidityFromAmounts({ poolInfo, tickLower, tickUpper, amountA, amountB, slippage, add }: {
        poolInfo: AmmV3PoolInfo;
        tickLower: number;
        tickUpper: number;
        amountA: BN;
        amountB: BN;
        slippage: number;
        add: boolean;
    }): ReturnTypeGetLiquidityAmountOutFromAmountIn;
    static getAmountsFromLiquidity({ poolInfo, ownerPosition, liquidity, slippage, add }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        liquidity: BN;
        slippage: number;
        add: boolean;
    }): ReturnTypeGetAmountsFromLiquidity;
    static getPriceAndTick({ poolInfo, price, baseIn }: {
        poolInfo: AmmV3PoolInfo;
        price: Decimal;
        baseIn: boolean;
    }): ReturnTypeGetPriceAndTick;
    static getTickPrice({ poolInfo, tick, baseIn }: {
        poolInfo: AmmV3PoolInfo;
        tick: number;
        baseIn: boolean;
    }): ReturnTypeGetTickPrice;
    static computeAmountOutFormat({ poolInfo, tickArrayCache, amountIn, currencyOut, slippage }: {
        poolInfo: AmmV3PoolInfo;
        tickArrayCache: {
            [key: string]: TickArray;
        };
        amountIn: CurrencyAmount | TokenAmount;
        currencyOut: Token | Currency;
        slippage: Percent;
    }): ReturnTypeComputeAmountOutFormat;
    static computeAmountOut({ poolInfo, tickArrayCache, baseMint, amountIn, slippage, priceLimit }: {
        poolInfo: AmmV3PoolInfo;
        tickArrayCache: {
            [key: string]: TickArray;
        };
        baseMint: PublicKey;
        amountIn: BN;
        slippage: number;
        priceLimit?: Decimal;
    }): ReturnTypeComputeAmountOut;
    static computeAmountIn({ poolInfo, tickArrayCache, baseMint, amountOut, slippage, priceLimit }: {
        poolInfo: AmmV3PoolInfo;
        tickArrayCache: {
            [key: string]: TickArray;
        };
        baseMint: PublicKey;
        amountOut: BN;
        slippage: number;
        priceLimit?: Decimal;
    }): ReturnTypeComputeAmountOutBaseOut;
    static estimateAprsForPriceRangeMultiplier({ poolInfo, aprType, positionTickLowerIndex, positionTickUpperIndex }: {
        poolInfo: AmmV3PoolInfo;
        aprType: 'day' | 'week' | 'month';
        positionTickLowerIndex: number;
        positionTickUpperIndex: number;
    }): {
        feeApr: number;
        rewardsApr: number[];
        apr: number;
    };
    static estimateAprsForPriceRangeDelta({ poolInfo, aprType, mintPrice, rewardMintDecimals, liquidity, positionTickLowerIndex, positionTickUpperIndex, chainTime }: {
        poolInfo: AmmV3PoolInfo;
        aprType: 'day' | 'week' | 'month';
        mintPrice: {
            [mint: string]: Price;
        };
        rewardMintDecimals: {
            [mint: string]: number;
        };
        liquidity: BN;
        positionTickLowerIndex: number;
        positionTickUpperIndex: number;
        chainTime: number;
    }): {
        feeApr: number;
        rewardsApr: number[];
        apr: number;
    };
    static fetchMultiplePoolInfos({ connection, poolKeys, ownerInfo, chainTime, batchRequest }: {
        connection: Connection;
        poolKeys: ApiAmmV3PoolsItem[];
        ownerInfo?: {
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
        };
        chainTime: number;
        batchRequest?: boolean;
    }): Promise<ReturnTypeFetchMultiplePoolInfos>;
    static fetchMultiplePoolTickArrays({ connection, poolKeys, batchRequest }: {
        connection: Connection;
        poolKeys: AmmV3PoolInfo[];
        batchRequest?: boolean;
    }): Promise<ReturnTypeFetchMultiplePoolTickArrays>;
    static getWhiteListMint({ connection, programId }: {
        connection: Connection;
        programId: PublicKey;
    }): Promise<PublicKey[]>;
}
//# sourceMappingURL=ammV3.d.ts.map