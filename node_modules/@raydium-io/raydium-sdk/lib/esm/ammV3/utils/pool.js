import { PublicKey } from '@solana/web3.js';
import BN from 'bn.js';
import { ZERO } from '../../entity';
import { NEGATIVE_ONE, Q64 } from './constants';
import { MathUtil, SwapMath } from './math';
import { getPdaTickArrayAddress } from './pda';
import { TickUtils } from './tick';
export class PoolUtils {
    static getOutputAmountAndRemainAccounts(poolInfo, tickArrayCache, inputTokenMint, inputAmount, sqrtPriceLimitX64) {
        const zeroForOne = inputTokenMint.equals(poolInfo.mintA.mint);
        const allNeededAccounts = [];
        const { isExist, startIndex: firstTickArrayStartIndex, nextAccountMeta } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
        if (!isExist || firstTickArrayStartIndex === undefined || !nextAccountMeta)
            throw new Error("Invalid tick array");
        try {
            const preTick = this.preInitializedTickArrayStartIndex(poolInfo, !zeroForOne);
            if (preTick.isExist) {
                const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
                allNeededAccounts.push(address);
            }
        }
        catch (e) { /* empty */ }
        allNeededAccounts.push(nextAccountMeta);
        const { amountCalculated: outputAmount, accounts: reaminAccounts, sqrtPriceX64: executionPrice, feeAmount } = SwapMath.swapCompute(poolInfo.programId, poolInfo.id, tickArrayCache, zeroForOne, poolInfo.ammConfig.tradeFeeRate, poolInfo.liquidity, poolInfo.tickCurrent, poolInfo.tickSpacing, poolInfo.sqrtPriceX64, inputAmount, firstTickArrayStartIndex, sqrtPriceLimitX64);
        allNeededAccounts.push(...reaminAccounts);
        return { expectedAmountOut: outputAmount.mul(NEGATIVE_ONE), remainingAccounts: allNeededAccounts, executionPrice, feeAmount };
    }
    static getInputAmountAndRemainAccounts(poolInfo, tickArrayCache, outputTokenMint, outputAmount, sqrtPriceLimitX64) {
        const zeroForOne = outputTokenMint.equals(poolInfo.mintB.mint);
        const allNeededAccounts = [];
        const { isExist, startIndex: firstTickArrayStartIndex, nextAccountMeta } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
        if (!isExist || firstTickArrayStartIndex === undefined || !nextAccountMeta)
            throw new Error("Invalid tick array");
        try {
            const preTick = this.preInitializedTickArrayStartIndex(poolInfo, !zeroForOne);
            if (preTick.isExist) {
                const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
                allNeededAccounts.push(address);
            }
        }
        catch (e) { /* empty */ }
        allNeededAccounts.push(nextAccountMeta);
        const { amountCalculated: inputAmount, accounts: reaminAccounts, sqrtPriceX64: executionPrice, feeAmount } = SwapMath.swapCompute(poolInfo.programId, poolInfo.id, tickArrayCache, zeroForOne, poolInfo.ammConfig.tradeFeeRate, poolInfo.liquidity, poolInfo.tickCurrent, poolInfo.tickSpacing, poolInfo.sqrtPriceX64, outputAmount.mul(NEGATIVE_ONE), firstTickArrayStartIndex, sqrtPriceLimitX64);
        allNeededAccounts.push(...reaminAccounts);
        return { expectedAmountIn: inputAmount, remainingAccounts: allNeededAccounts, executionPrice, feeAmount };
    }
    static getFirstInitializedTickArray(poolInfo, zeroForOne) {
        const tickArrayBitmap = TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap);
        const { isInitialized, startIndex } = TickUtils.checkTickArrayIsInitialized(tickArrayBitmap, poolInfo.tickCurrent, poolInfo.tickSpacing);
        if (isInitialized) {
            const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, startIndex);
            return {
                isExist: true,
                startIndex,
                nextAccountMeta: address
            };
        }
        const { isExist, nextStartIndex } = this.nextInitializedTickArrayStartIndex(poolInfo, zeroForOne);
        if (isExist) {
            const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, nextStartIndex);
            return {
                isExist: true,
                startIndex: nextStartIndex,
                nextAccountMeta: address
            };
        }
        return { isExist: false, nextAccountMeta: undefined, startIndex: undefined };
    }
    static preInitializedTickArrayStartIndex(poolInfo, zeroForOne) {
        const tickArrayBitmap = TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap);
        const currentOffset = TickUtils.getTickArrayOffsetInBitmapByTick(poolInfo.tickCurrent, poolInfo.tickSpacing);
        const result = zeroForOne ? TickUtils.searchLowBitFromStart(tickArrayBitmap, currentOffset - 1, 0, 1, poolInfo.tickSpacing) : TickUtils.searchHightBitFromStart(tickArrayBitmap, currentOffset + 1, 1024, 1, poolInfo.tickSpacing);
        return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
    }
    static nextInitializedTickArrayStartIndex(poolInfo, zeroForOne) {
        const tickArrayBitmap = TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap);
        const currentOffset = TickUtils.getTickArrayOffsetInBitmapByTick(poolInfo.tickCurrent, poolInfo.tickSpacing);
        const result = zeroForOne ? TickUtils.searchLowBitFromStart(tickArrayBitmap, currentOffset - 1, 0, 1, poolInfo.tickSpacing) : TickUtils.searchHightBitFromStart(tickArrayBitmap, currentOffset, 1024, 1, poolInfo.tickSpacing);
        return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
    }
    static updatePoolRewardInfos({ chainTime, poolLiquidity, rewardInfos }) {
        const nRewardInfo = [];
        for (const _itemReward of rewardInfos) {
            const itemReward = {
                ..._itemReward,
                perSecond: MathUtil.x64ToDecimal(_itemReward.emissionsPerSecondX64),
                remainingRewards: undefined
            };
            if (itemReward.tokenMint.equals(PublicKey.default))
                continue;
            if (chainTime <= itemReward.openTime.toNumber() || poolLiquidity.eq(ZERO)) {
                nRewardInfo.push(itemReward);
                continue;
            }
            const latestUpdateTime = new BN(Math.min(itemReward.endTime.toNumber(), chainTime));
            const timeDelta = latestUpdateTime.sub(itemReward.lastUpdateTime);
            const rewardGrowthDeltaX64 = MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, poolLiquidity);
            const rewardGrowthGlobalX64 = itemReward.rewardGrowthGlobalX64.add(rewardGrowthDeltaX64);
            const rewardEmissionedDelta = MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, Q64);
            const rewardTotalEmissioned = itemReward.rewardTotalEmissioned.add(rewardEmissionedDelta);
            nRewardInfo.push({
                ...itemReward,
                rewardGrowthGlobalX64,
                rewardTotalEmissioned,
                lastUpdateTime: latestUpdateTime
            });
        }
        return nRewardInfo;
    }
}
//# sourceMappingURL=pool.js.map