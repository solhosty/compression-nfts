import BN from "bn.js";
import { getPdaTickArrayAddress } from "./pda";
export const TICK_ARRAY_SIZE = 60;
export const TICK_ARRAY_BITMAP_SIZE = 1024;
export class TickUtils {
    static getTickArrayAddressByTick(programId, poolId, tickIndex, tickSpacing) {
        const startIndex = TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
        const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, startIndex);
        return tickArrayAddress;
    }
    static getTickOffsetInArray(tickIndex, tickSpacing) {
        if (tickIndex % tickSpacing != 0) {
            throw new Error('tickIndex % tickSpacing not equal 0');
        }
        const startTickIndex = TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
        const offsetInArray = Math.floor((tickIndex - startTickIndex) / tickSpacing);
        if (offsetInArray < 0 || offsetInArray >= TICK_ARRAY_SIZE) {
            throw new Error('tick offset in array overflow');
        }
        return offsetInArray;
    }
    static getTickArrayStartIndexByTick(tickIndex, tickSpacing) {
        let startIndex = tickIndex / (TICK_ARRAY_SIZE * tickSpacing);
        if (tickIndex < 0 && tickIndex % (TICK_ARRAY_SIZE * tickSpacing) != 0) {
            startIndex = Math.ceil(startIndex) - 1;
        }
        else {
            startIndex = Math.floor(startIndex);
        }
        return startIndex * (tickSpacing * TICK_ARRAY_SIZE);
    }
    static getTickArrayOffsetInBitmapByTick(tick, tickSpacing) {
        const multiplier = tickSpacing * TICK_ARRAY_SIZE;
        const compressed = Math.floor(tick / multiplier) + 512;
        return Math.abs(compressed);
    }
    static checkTickArrayIsInitialized(bitmap, tick, tickSpacing) {
        const multiplier = tickSpacing * TICK_ARRAY_SIZE;
        const compressed = Math.floor(tick / multiplier) + 512;
        const bit_pos = Math.abs(compressed);
        return {
            isInitialized: bitmap.testn(bit_pos),
            startIndex: (bit_pos - 512) * multiplier
        };
    }
    static getNextTickArrayStartIndex(lastTickArrayStartIndex, tickSpacing, zeroForOne) {
        return zeroForOne ? lastTickArrayStartIndex - tickSpacing * TICK_ARRAY_SIZE : lastTickArrayStartIndex + tickSpacing * TICK_ARRAY_SIZE;
    }
    static mergeTickArrayBitmap(bns) {
        return bns[0]
            .add(bns[1].shln(64))
            .add(bns[2].shln(128))
            .add(bns[3].shln(192))
            .add(bns[4].shln(256))
            .add(bns[5].shln(320))
            .add(bns[6].shln(384))
            .add(bns[7].shln(448))
            .add(bns[8].shln(512))
            .add(bns[9].shln(576))
            .add(bns[10].shln(640))
            .add(bns[11].shln(704))
            .add(bns[12].shln(768))
            .add(bns[13].shln(832))
            .add(bns[14].shln(896))
            .add(bns[15].shln(960));
    }
    static getInitializedTickArrayInRange(tickArrayBitmap, tickSpacing, tickArrayStartIndex, expectedCount) {
        if (tickArrayStartIndex % (tickSpacing * TICK_ARRAY_SIZE) != 0) {
            throw new Error('Invild tickArrayStartIndex');
        }
        const tickArrayOffset = Math.floor(tickArrayStartIndex / (tickSpacing * TICK_ARRAY_SIZE)) + 512;
        return [
            // find right of currenct offset
            ...TickUtils.searchLowBitFromStart(tickArrayBitmap, tickArrayOffset - 1, 0, expectedCount, tickSpacing),
            // find left of current offset
            ...TickUtils.searchHightBitFromStart(tickArrayBitmap, tickArrayOffset, TICK_ARRAY_BITMAP_SIZE, expectedCount, tickSpacing)
        ];
    }
    static getAllInitializedTickArrayStartIndex(tickArrayBitmap, tickSpacing) {
        // find from offset 0 to 1024
        return TickUtils.searchHightBitFromStart(tickArrayBitmap, 0, TICK_ARRAY_BITMAP_SIZE, TICK_ARRAY_BITMAP_SIZE, tickSpacing);
    }
    static getAllInitializedTickArrayInfo(programId, poolId, tickArrayBitmap, tickSpacing) {
        const result = [];
        const allInitializedTickArrayIndex = TickUtils.getAllInitializedTickArrayStartIndex(tickArrayBitmap, tickSpacing);
        for (const startIndex of allInitializedTickArrayIndex) {
            const { publicKey: address } = getPdaTickArrayAddress(programId, poolId, startIndex);
            result.push({
                tickArrayStartIndex: startIndex,
                tickArrayAddress: address,
            });
        }
        return result;
    }
    static getAllInitializedTickInTickArray(tickArray) {
        return tickArray.ticks.filter(i => i.liquidityGross.gtn(0));
    }
    static searchLowBitFromStart(tickArrayBitmap, start, end, expectedCount, tickSpacing) {
        let fetchNum = 0;
        const result = [];
        for (let i = start; i >= end; i--) {
            if (tickArrayBitmap.shrn(i).and(new BN(1)).eqn(1)) {
                const nextStartIndex = (i - 512) * (tickSpacing * TICK_ARRAY_SIZE);
                result.push(nextStartIndex);
                fetchNum++;
            }
            if (fetchNum >= expectedCount) {
                break;
            }
        }
        return result;
    }
    static searchHightBitFromStart(tickArrayBitmap, start, end, expectedCount, tickSpacing) {
        let fetchNum = 0;
        const result = [];
        for (let i = start; i < end; i++) {
            if (tickArrayBitmap.shrn(i).and(new BN(1)).eqn(1)) {
                const nextStartIndex = (i - 512) * (tickSpacing * TICK_ARRAY_SIZE);
                result.push(nextStartIndex);
                fetchNum++;
            }
            if (fetchNum >= expectedCount) {
                break;
            }
        }
        return result;
    }
}
//# sourceMappingURL=tick.js.map