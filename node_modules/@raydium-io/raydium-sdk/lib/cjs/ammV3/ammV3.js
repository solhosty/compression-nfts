"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmV3 = void 0;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
const decimal_js_1 = __importDefault(require("decimal.js"));
const base_1 = require("../base");
const instrument_1 = require("../base/instrument");
const pda_1 = require("../base/pda");
const common_1 = require("../common");
const entity_1 = require("../entity");
const spl_1 = require("../spl");
const instrument_2 = require("./instrument");
const layout_1 = require("./layout");
const constants_1 = require("./utils/constants");
const math_1 = require("./utils/math");
const pda_2 = require("./utils/pda");
const pool_1 = require("./utils/pool");
const position_1 = require("./utils/position");
const tick_1 = require("./utils/tick");
const tickQuery_1 = require("./utils/tickQuery");
const logger = common_1.Logger.from("AmmV3");
class AmmV3 extends base_1.Base {
    static makeMockPoolInfo({ programId, mint1, mint2, ammConfig, createPoolInstructionSimpleAddress, initialPrice, startTime, owner }) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const [mintA, mintB, initPrice] = mint1.mint._bn.gt(mint2.mint._bn) ? [mint2, mint1, (new decimal_js_1.default(1)).div(initialPrice)] : [mint1, mint2, initialPrice];
        const initialPriceX64 = math_1.SqrtPriceMath.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
        return {
            id: createPoolInstructionSimpleAddress.poolId,
            mintA: {
                mint: createPoolInstructionSimpleAddress.mintA,
                vault: createPoolInstructionSimpleAddress.mintAVault,
                decimals: mintA.decimals
            },
            mintB: {
                mint: createPoolInstructionSimpleAddress.mintB,
                vault: createPoolInstructionSimpleAddress.mintBVault,
                decimals: mintB.decimals
            },
            ammConfig,
            observationId: createPoolInstructionSimpleAddress.observationId,
            creator: owner,
            programId,
            version: 6,
            tickSpacing: ammConfig.tickSpacing,
            liquidity: entity_1.ZERO,
            sqrtPriceX64: initialPriceX64,
            currentPrice: initPrice,
            tickCurrent: 0,
            observationIndex: 0,
            observationUpdateDuration: 0,
            feeGrowthGlobalX64A: entity_1.ZERO,
            feeGrowthGlobalX64B: entity_1.ZERO,
            protocolFeesTokenA: entity_1.ZERO,
            protocolFeesTokenB: entity_1.ZERO,
            swapInAmountTokenA: entity_1.ZERO,
            swapOutAmountTokenB: entity_1.ZERO,
            swapInAmountTokenB: entity_1.ZERO,
            swapOutAmountTokenA: entity_1.ZERO,
            tickArrayBitmap: [],
            rewardInfos: [],
            day: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 },
            week: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 },
            month: { volume: 0, volumeFee: 0, feeA: 0, feeB: 0, feeApr: 0, rewardApr: { A: 0, B: 0, C: 0 }, apr: 0, priceMax: 0, priceMin: 0 },
            tvl: 0,
            lookupTableAccount: web3_js_1.PublicKey.default,
            startTime: startTime.toNumber(),
        };
    }
    // transaction
    static makeCreatePoolInstructionSimple({ connection, programId, owner, mint1, mint2, ammConfig, initialPrice, startTime, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const [mintA, mintB, initPrice] = mint1.mint._bn.gt(mint2.mint._bn) ? [mint2, mint1, (new decimal_js_1.default(1)).div(initialPrice)] : [mint1, mint2, initialPrice];
            const initialPriceX64 = math_1.SqrtPriceMath.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
            const makeCreatePoolInstructions = yield this.makeCreatePoolInstructions({
                connection,
                programId,
                owner,
                mintA,
                mintB,
                ammConfigId: ammConfig.id,
                initialPriceX64,
                startTime
            });
            return {
                address: Object.assign(Object.assign({}, makeCreatePoolInstructions.address), { mintA: mintA.mint, mintB: mintB.mint }),
                innerTransactions: [{
                        instructions: [...instructions, ...makeCreatePoolInstructions.innerTransaction.instructions],
                        signers: makeCreatePoolInstructions.innerTransaction.signers,
                        instructionTypes: [...instructionTypes, ...makeCreatePoolInstructions.innerTransaction.instructionTypes],
                        supportedVersion: makeCreatePoolInstructions.innerTransaction.supportedVersion
                    }]
            };
        });
    }
    static makeOpenPositionInstructionSimple({ connection, poolInfo, ownerInfo, tickLower, tickUpper, liquidity, slippage, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            // const tickLower = TickMath.getTickWithPriceAndTickspacing(
            //   priceLower,
            //   poolInfo.ammConfig.tickSpacing,
            //   poolInfo.mintA.decimals,
            //   poolInfo.mintB.decimals
            // );
            // const tickUpper = TickMath.getTickWithPriceAndTickspacing(
            //   priceUpper,
            //   poolInfo.ammConfig.tickSpacing,
            //   poolInfo.mintA.decimals,
            //   poolInfo.mintB.decimals
            // );
            const { amountSlippageA, amountSlippageB } = math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolInfo.sqrtPriceX64, math_1.SqrtPriceMath.getSqrtPriceX64FromTick(tickLower), math_1.SqrtPriceMath.getSqrtPriceX64FromTick(tickUpper), liquidity, true, true, slippage);
            const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(entity_1.Token.WSOL.mint);
            const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(entity_1.Token.WSOL.mint);
            const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintA.mint,
                tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintAUseSOLBalance ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: amountSlippageA,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintAUseSOLBalance ? false : associatedOnly
            });
            const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintB.mint,
                tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintBUseSOLBalance ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: amountSlippageB,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintBUseSOLBalance ? false : associatedOnly
            });
            logger.assertArgument(ownerTokenAccountA !== undefined && ownerTokenAccountB !== undefined, "cannot found target token accounts", "tokenAccounts", ownerInfo.tokenAccounts);
            const makeOpenPositionInstructions = this.makeOpenPositionInstructions({
                poolInfo,
                ownerInfo: Object.assign(Object.assign({}, ownerInfo), { tokenAccountA: ownerTokenAccountA, tokenAccountB: ownerTokenAccountB }),
                tickLower,
                tickUpper,
                liquidity,
                amountSlippageA,
                amountSlippageB,
            });
            return {
                address: makeOpenPositionInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeOpenPositionInstructions.innerTransaction.instructions, ...endInstructions],
                        signers: [...signers, ...makeOpenPositionInstructions.innerTransaction.signers],
                        lookupTableAddress: makeOpenPositionInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeOpenPositionInstructions.innerTransaction.instructionTypes, ...endInstructionsType],
                        supportedVersion: makeOpenPositionInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeIncreaseLiquidityInstructionSimple({ connection, poolInfo, ownerPosition, ownerInfo, liquidity, slippage, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            const { amountSlippageA, amountSlippageB } = math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolInfo.sqrtPriceX64, math_1.SqrtPriceMath.getSqrtPriceX64FromTick(ownerPosition.tickLower), math_1.SqrtPriceMath.getSqrtPriceX64FromTick(ownerPosition.tickUpper), liquidity, true, true, slippage);
            const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(entity_1.Token.WSOL.mint);
            const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(entity_1.Token.WSOL.mint);
            const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintA.mint,
                tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintAUseSOLBalance ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: amountSlippageA,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintAUseSOLBalance ? false : associatedOnly
            });
            const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintB.mint,
                tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintBUseSOLBalance ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: amountSlippageB,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintBUseSOLBalance ? false : associatedOnly
            });
            logger.assertArgument(!!ownerTokenAccountA || !!ownerTokenAccountB, "cannot found target token accounts", "tokenAccounts", ownerInfo.tokenAccounts);
            const makeIncreaseLiquidityInstructions = this.makeIncreaseLiquidityInstructions({
                poolInfo,
                ownerPosition,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccountA: ownerTokenAccountA,
                    tokenAccountB: ownerTokenAccountB
                },
                liquidity,
                amountSlippageA,
                amountSlippageB
            });
            return {
                address: makeIncreaseLiquidityInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeIncreaseLiquidityInstructions.innerTransaction.instructions, ...endInstructions],
                        signers: [...signers, ...makeIncreaseLiquidityInstructions.innerTransaction.signers],
                        lookupTableAddress: makeIncreaseLiquidityInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeIncreaseLiquidityInstructions.innerTransaction.instructionTypes, ...endInstructionsType],
                        supportedVersion: makeIncreaseLiquidityInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeDecreaseLiquidityInstructionSimple({ connection, poolInfo, ownerPosition, ownerInfo, liquidity, amountMinA, amountMinB, slippage, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            let _amountMinA;
            let _amountMinB;
            if (amountMinA !== undefined && amountMinB !== undefined) {
                _amountMinA = amountMinA;
                _amountMinB = amountMinB;
            }
            else {
                const { amountSlippageA, amountSlippageB } = math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolInfo.sqrtPriceX64, math_1.SqrtPriceMath.getSqrtPriceX64FromTick(ownerPosition.tickLower), math_1.SqrtPriceMath.getSqrtPriceX64FromTick(ownerPosition.tickUpper), liquidity, false, true, slippage !== null && slippage !== void 0 ? slippage : 0);
                _amountMinA = amountSlippageA;
                _amountMinB = amountSlippageB;
            }
            const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(entity_1.Token.WSOL.mint);
            const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(entity_1.Token.WSOL.mint);
            const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintA.mint,
                tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: 0,
                    frontInstructions,
                    frontInstructionsType,
                    endInstructions: mintAUseSOLBalance ? endInstructions : [],
                    endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
                    signers
                },
                associatedOnly: mintAUseSOLBalance ? false : associatedOnly
            });
            const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintB.mint,
                tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: 0,
                    frontInstructions,
                    frontInstructionsType,
                    endInstructions: mintBUseSOLBalance ? endInstructions : [],
                    endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
                    signers
                },
                associatedOnly: mintBUseSOLBalance ? false : associatedOnly
            });
            const rewardAccounts = [];
            for (const itemReward of poolInfo.rewardInfos) {
                const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(entity_1.Token.WSOL.mint);
                const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
                    mint: itemReward.tokenMint,
                    tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                    owner: ownerInfo.wallet,
                    createInfo: {
                        connection,
                        payer: ownerInfo.feePayer,
                        amount: 0,
                        frontInstructions,
                        frontInstructionsType,
                        endInstructions: rewardUseSOLBalance ? endInstructions : [],
                        endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
                        signers
                    },
                    associatedOnly: rewardUseSOLBalance ? false : associatedOnly
                });
                rewardAccounts.push(ownerRewardAccount);
            }
            logger.assertArgument(!!ownerTokenAccountA || !!ownerTokenAccountB, "cannot found target token accounts", "tokenAccounts", ownerInfo.tokenAccounts);
            const makeDecreaseLiquidityInstructions = this.makeDecreaseLiquidityInstructions({
                poolInfo,
                ownerPosition,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccountA: ownerTokenAccountA,
                    tokenAccountB: ownerTokenAccountB,
                    rewardAccounts
                },
                liquidity,
                amountMinA: _amountMinA,
                amountMinB: _amountMinB
            });
            const makeClosePositionInstructions = ownerInfo.closePosition ? this.makeClosePositionInstructions({
                poolInfo, ownerInfo, ownerPosition
            }) : { address: {}, innerTransaction: { instructions: [], signers: [], instructionTypes: [], supportedVersion: [] } };
            return {
                address: makeDecreaseLiquidityInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeDecreaseLiquidityInstructions.innerTransaction.instructions, ...endInstructions, ...makeClosePositionInstructions.innerTransaction.instructions],
                        signers: [...signers, ...makeDecreaseLiquidityInstructions.innerTransaction.signers],
                        lookupTableAddress: makeDecreaseLiquidityInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeDecreaseLiquidityInstructions.innerTransaction.instructionTypes, ...endInstructionsType, ...makeClosePositionInstructions.innerTransaction.instructionTypes],
                        supportedVersion: makeDecreaseLiquidityInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeSwapBaseInInstructionSimple({ connection, poolInfo, ownerInfo, inputMint, amountIn, amountOutMin, priceLimit, remainingAccounts, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            let sqrtPriceLimitX64;
            if (!priceLimit || priceLimit.equals(new decimal_js_1.default(0))) {
                sqrtPriceLimitX64 = inputMint.equals(poolInfo.mintA.mint)
                    ? constants_1.MIN_SQRT_PRICE_X64.add(entity_1.ONE)
                    : constants_1.MAX_SQRT_PRICE_X64.sub(entity_1.ONE);
            }
            else {
                sqrtPriceLimitX64 = math_1.SqrtPriceMath.priceToSqrtPriceX64(priceLimit, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
            }
            const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
            const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(entity_1.Token.WSOL.mint);
            const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(entity_1.Token.WSOL.mint);
            const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintA.mint,
                tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintAUseSOLBalance || !isInputMintA ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: isInputMintA ? amountIn : 0,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintAUseSOLBalance ? false : associatedOnly
            });
            const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintB.mint,
                tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintBUseSOLBalance || isInputMintA ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: isInputMintA ? 0 : amountIn,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintBUseSOLBalance ? false : associatedOnly
            });
            logger.assertArgument(!!ownerTokenAccountA || !!ownerTokenAccountB, "cannot found target token accounts", "tokenAccounts", ownerInfo.tokenAccounts);
            const makeSwapBaseInInstructions = this.makeSwapBaseInInstructions({
                poolInfo,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccountA: ownerTokenAccountA,
                    tokenAccountB: ownerTokenAccountB
                },
                inputMint,
                amountIn,
                amountOutMin,
                sqrtPriceLimitX64,
                remainingAccounts,
            });
            return {
                address: makeSwapBaseInInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeSwapBaseInInstructions.innerTransaction.instructions, ...endInstructions],
                        signers: [...signers, ...makeSwapBaseInInstructions.innerTransaction.signers],
                        lookupTableAddress: makeSwapBaseInInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeSwapBaseInInstructions.innerTransaction.instructionTypes, ...endInstructionsType],
                        supportedVersion: makeSwapBaseInInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeSwapBaseOutInstructionSimple({ connection, poolInfo, ownerInfo, outputMint, amountOut, amountInMax, priceLimit, remainingAccounts, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            let sqrtPriceLimitX64;
            if (!priceLimit || priceLimit.equals(new decimal_js_1.default(0))) {
                sqrtPriceLimitX64 = outputMint.equals(poolInfo.mintB.mint)
                    ? constants_1.MIN_SQRT_PRICE_X64.add(entity_1.ONE)
                    : constants_1.MAX_SQRT_PRICE_X64.sub(entity_1.ONE);
            }
            else {
                sqrtPriceLimitX64 = math_1.SqrtPriceMath.priceToSqrtPriceX64(priceLimit, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
            }
            const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
            const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(entity_1.Token.WSOL.mint);
            const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(entity_1.Token.WSOL.mint);
            const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintA.mint,
                tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintAUseSOLBalance || !isInputMintA ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: isInputMintA ? amountInMax : 0,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintAUseSOLBalance ? false : associatedOnly
            });
            const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
                mint: poolInfo.mintB.mint,
                tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: mintBUseSOLBalance || isInputMintA ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: isInputMintA ? 0 : amountInMax,
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: mintBUseSOLBalance ? false : associatedOnly
            });
            logger.assertArgument(!!ownerTokenAccountA || !!ownerTokenAccountB, "cannot found target token accounts", "tokenAccounts", ownerInfo.tokenAccounts);
            const makeSwapBaseOutInstructions = this.makeSwapBaseOutInstructions({
                poolInfo,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccountA: ownerTokenAccountA,
                    tokenAccountB: ownerTokenAccountB
                },
                outputMint,
                amountOut,
                amountInMax,
                sqrtPriceLimitX64,
                remainingAccounts,
            });
            return {
                address: makeSwapBaseOutInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeSwapBaseOutInstructions.innerTransaction.instructions, ...endInstructions],
                        signers: [...signers, ...makeSwapBaseOutInstructions.innerTransaction.signers],
                        lookupTableAddress: makeSwapBaseOutInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeSwapBaseOutInstructions.innerTransaction.instructionTypes, ...endInstructionsType],
                        supportedVersion: makeSwapBaseOutInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeCLosePositionInstructionSimple({ poolInfo, ownerPosition, ownerInfo }) {
        const data = this.makeClosePositionInstructions({ poolInfo, ownerInfo, ownerPosition });
        return {
            address: data.address,
            innerTransactions: [data.innerTransaction]
        };
    }
    static makeInitRewardInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfo, chainTime, associatedOnly = true }) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
            logger.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(entity_1.Token.WSOL.mint);
            const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
                mint: rewardInfo.mint,
                tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: rewardMintUseSOLBalance ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: new bn_js_1.default(new decimal_js_1.default(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)),
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly
            });
            logger.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
            const makeInitRewardInstructions = this.makeInitRewardInstructions({
                poolInfo,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccount: ownerRewardAccount
                },
                rewardInfo: {
                    mint: rewardInfo.mint,
                    openTime: rewardInfo.openTime,
                    endTime: rewardInfo.endTime,
                    emissionsPerSecondX64: math_1.MathUtil.decimalToX64(rewardInfo.perSecond)
                }
            });
            return {
                address: makeInitRewardInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...frontInstructions, ...makeInitRewardInstructions.innerTransaction.instructions, ...endInstructions],
                        signers: [...signers, ...makeInitRewardInstructions.innerTransaction.signers],
                        lookupTableAddress: makeInitRewardInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...frontInstructionsType, ...makeInitRewardInstructions.innerTransaction.instructionTypes, ...endInstructionsType],
                        supportedVersion: makeInitRewardInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeInitRewardsInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfos, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const rewardInfo of rewardInfos)
                logger.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const makeInitRewardInstructions = [];
            const signers = [];
            for (const rewardInfo of rewardInfos) {
                const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(entity_1.Token.WSOL.mint);
                const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
                    mint: rewardInfo.mint,
                    tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                    owner: ownerInfo.wallet,
                    createInfo: rewardMintUseSOLBalance ? {
                        connection,
                        payer: ownerInfo.feePayer,
                        amount: new bn_js_1.default(new decimal_js_1.default(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)),
                        frontInstructions,
                        endInstructions,
                        frontInstructionsType,
                        endInstructionsType,
                        signers
                    } : undefined,
                    associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly
                });
                logger.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
                makeInitRewardInstructions.push(this.makeInitRewardInstructions({
                    poolInfo,
                    ownerInfo: {
                        wallet: ownerInfo.wallet,
                        tokenAccount: ownerRewardAccount
                    },
                    rewardInfo: {
                        mint: rewardInfo.mint,
                        openTime: rewardInfo.openTime,
                        endTime: rewardInfo.endTime,
                        emissionsPerSecondX64: math_1.MathUtil.decimalToX64(rewardInfo.perSecond)
                    }
                }));
            }
            let address = {};
            for (const item of makeInitRewardInstructions) {
                address = Object.assign(Object.assign({}, address), item.address);
            }
            return {
                address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeInitRewardInstructions.map(i => i.innerTransaction.instructions).flat(), ...endInstructions],
                        signers: [...signers, ...makeInitRewardInstructions.map(i => i.innerTransaction.signers).flat()],
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeInitRewardInstructions.map(i => i.innerTransaction.instructionTypes).flat(), ...endInstructionsType],
                        supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                    }
                ]
            };
        });
    }
    static makeSetRewardInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfo, chainTime, associatedOnly = true, }) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
            logger.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(entity_1.Token.WSOL.mint);
            const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
                mint: rewardInfo.mint,
                tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: rewardMintUseSOLBalance ? {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: new bn_js_1.default(new decimal_js_1.default(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)),
                    frontInstructions,
                    endInstructions,
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                } : undefined,
                associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly
            });
            logger.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
            const makeSetRewardInstructions = this.makeSetRewardInstructions({
                poolInfo,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccount: ownerRewardAccount
                },
                rewardInfo: {
                    mint: rewardInfo.mint,
                    openTime: rewardInfo.openTime,
                    endTime: rewardInfo.endTime,
                    emissionsPerSecondX64: math_1.MathUtil.decimalToX64(rewardInfo.perSecond)
                }
            });
            return {
                address: makeSetRewardInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...frontInstructions, ...makeSetRewardInstructions.innerTransaction.instructions, ...endInstructions],
                        signers: [...signers, ...makeSetRewardInstructions.innerTransaction.signers],
                        lookupTableAddress: makeSetRewardInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...frontInstructionsType, ...makeSetRewardInstructions.innerTransaction.instructionTypes, ...endInstructionsType],
                        supportedVersion: makeSetRewardInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeSetRewardsInstructionSimple({ connection, poolInfo, ownerInfo, rewardInfos, chainTime, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const makeSetRewardInstructions = [];
            const signers = [];
            for (const rewardInfo of rewardInfos) {
                logger.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
                logger.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
                const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(entity_1.Token.WSOL.mint);
                const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
                    mint: rewardInfo.mint,
                    tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                    owner: ownerInfo.wallet,
                    createInfo: rewardMintUseSOLBalance ? {
                        connection,
                        payer: ownerInfo.feePayer,
                        amount: new bn_js_1.default(new decimal_js_1.default(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)),
                        frontInstructions,
                        endInstructions,
                        frontInstructionsType,
                        endInstructionsType,
                        signers
                    } : undefined,
                    associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly
                });
                logger.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
                makeSetRewardInstructions.push(this.makeSetRewardInstructions({
                    poolInfo,
                    ownerInfo: {
                        wallet: ownerInfo.wallet,
                        tokenAccount: ownerRewardAccount
                    },
                    rewardInfo: {
                        mint: rewardInfo.mint,
                        openTime: rewardInfo.openTime,
                        endTime: rewardInfo.endTime,
                        emissionsPerSecondX64: math_1.MathUtil.decimalToX64(rewardInfo.perSecond)
                    }
                }));
            }
            let address = {};
            for (const item of makeSetRewardInstructions) {
                address = Object.assign(Object.assign({}, address), item.address);
            }
            return {
                address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeSetRewardInstructions.map(i => i.innerTransaction.instructions).flat(), ...endInstructions],
                        signers: [...signers, ...makeSetRewardInstructions.map(i => i.innerTransaction.signers).flat()],
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeSetRewardInstructions.map(i => i.innerTransaction.instructionTypes).flat(), ...endInstructionsType],
                        supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                    }
                ]
            };
        });
    }
    static makeCollectRewardInstructionSimple({ connection, poolInfo, ownerInfo, rewardMint, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(entity_1.Token.WSOL.mint);
            const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
                mint: rewardMint,
                tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                owner: ownerInfo.wallet,
                createInfo: {
                    connection,
                    payer: ownerInfo.feePayer,
                    amount: 0,
                    frontInstructions,
                    endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
                    frontInstructionsType,
                    endInstructionsType,
                    signers
                },
                associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly
            });
            logger.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
            const makeCollectRewardInstructions = this.makeCollectRewardInstructions({
                poolInfo,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    tokenAccount: ownerRewardAccount
                },
                rewardMint
            });
            return {
                address: makeCollectRewardInstructions.address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeCollectRewardInstructions.innerTransaction.instructions, ...endInstructions],
                        signers: [...signers, ...makeCollectRewardInstructions.innerTransaction.signers],
                        lookupTableAddress: makeCollectRewardInstructions.innerTransaction.lookupTableAddress,
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeCollectRewardInstructions.innerTransaction.instructionTypes, ...endInstructionsType],
                        supportedVersion: makeCollectRewardInstructions.innerTransaction.supportedVersion
                    }
                ]
            };
        });
    }
    static makeCollectRewardsInstructionSimple({ connection, poolInfo, ownerInfo, rewardMints, associatedOnly = true, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const makeCollectRewardInstructions = [];
            const signers = [];
            for (const rewardMint of rewardMints) {
                const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(entity_1.Token.WSOL.mint);
                const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
                    mint: rewardMint,
                    tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                    owner: ownerInfo.wallet,
                    createInfo: {
                        connection,
                        payer: ownerInfo.feePayer,
                        amount: 0,
                        frontInstructions,
                        endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
                        signers,
                        frontInstructionsType,
                        endInstructionsType
                    },
                    associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly
                });
                logger.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
                makeCollectRewardInstructions.push(this.makeCollectRewardInstructions({
                    poolInfo,
                    ownerInfo: {
                        wallet: ownerInfo.wallet,
                        tokenAccount: ownerRewardAccount
                    },
                    rewardMint
                }));
            }
            let address = {};
            for (const item of makeCollectRewardInstructions) {
                address = Object.assign(Object.assign({}, address), item.address);
            }
            return {
                address,
                innerTransactions: [
                    {
                        instructions: [...instructions, ...frontInstructions, ...makeCollectRewardInstructions.map(i => i.innerTransaction.instructions).flat(), ...endInstructions],
                        signers: [...signers, ...makeCollectRewardInstructions.map(i => i.innerTransaction.signers).flat()],
                        instructionTypes: [...instructionTypes, ...frontInstructionsType, ...makeCollectRewardInstructions.map(i => i.innerTransaction.instructionTypes).flat(), ...endInstructionsType],
                        supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                    }
                ]
            };
        });
    }
    static makeHarvestAllRewardInstructionSimple({ connection, fetchPoolInfos, ownerInfo, associatedOnly = true }) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const ownerMintToAccount = {};
            for (const item of ownerInfo.tokenAccounts) {
                if (associatedOnly) {
                    const ata = (0, pda_1.getATAAddress)(ownerInfo.wallet, item.accountInfo.mint).publicKey;
                    if (ata.equals(item.pubkey))
                        ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
                }
                else {
                    ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
                }
            }
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const makeDecreaseLiquidityInstructions = [];
            const signers = [];
            for (const itemInfo of Object.values(fetchPoolInfos)) {
                if (itemInfo.positionAccount === undefined)
                    continue;
                if (!itemInfo.positionAccount.find(i => !i.tokenFeeAmountA.isZero() || !i.tokenFeeAmountB.isZero() || i.rewardInfos.find(ii => !ii.pendingReward.isZero())))
                    continue;
                const poolInfo = itemInfo.state;
                const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(entity_1.Token.WSOL.mint);
                const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(entity_1.Token.WSOL.mint);
                const ownerTokenAccountA = (_a = ownerMintToAccount[poolInfo.mintA.mint.toString()]) !== null && _a !== void 0 ? _a : yield this._selectOrCreateTokenAccount({
                    mint: poolInfo.mintA.mint,
                    tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                    owner: ownerInfo.wallet,
                    createInfo: {
                        connection,
                        payer: ownerInfo.feePayer,
                        amount: 0,
                        frontInstructions,
                        frontInstructionsType,
                        endInstructions: mintAUseSOLBalance ? endInstructions : [],
                        endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
                        signers
                    },
                    associatedOnly: mintAUseSOLBalance ? false : associatedOnly
                });
                const ownerTokenAccountB = (_b = ownerMintToAccount[poolInfo.mintB.mint.toString()]) !== null && _b !== void 0 ? _b : yield this._selectOrCreateTokenAccount({
                    mint: poolInfo.mintB.mint,
                    tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                    owner: ownerInfo.wallet,
                    createInfo: {
                        connection,
                        payer: ownerInfo.feePayer,
                        amount: 0,
                        frontInstructions,
                        frontInstructionsType,
                        endInstructions: mintBUseSOLBalance ? endInstructions : [],
                        endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
                        signers
                    },
                    associatedOnly: mintBUseSOLBalance ? false : associatedOnly
                });
                ownerMintToAccount[poolInfo.mintA.mint.toString()] = ownerTokenAccountA;
                ownerMintToAccount[poolInfo.mintB.mint.toString()] = ownerTokenAccountB;
                const rewardAccounts = [];
                for (const itemReward of poolInfo.rewardInfos) {
                    const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(entity_1.Token.WSOL.mint);
                    const ownerRewardAccount = (_c = ownerMintToAccount[itemReward.tokenMint.toString()]) !== null && _c !== void 0 ? _c : yield this._selectOrCreateTokenAccount({
                        mint: itemReward.tokenMint,
                        tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
                        owner: ownerInfo.wallet,
                        createInfo: {
                            connection,
                            payer: ownerInfo.feePayer,
                            amount: 0,
                            frontInstructions,
                            endInstructions: rewardUseSOLBalance ? endInstructions : [],
                            frontInstructionsType,
                            endInstructionsType,
                            signers
                        },
                        associatedOnly: rewardUseSOLBalance ? false : associatedOnly
                    });
                    ownerMintToAccount[itemReward.tokenMint.toString()] = ownerRewardAccount;
                    rewardAccounts.push(ownerRewardAccount);
                }
                for (const itemPosition of itemInfo.positionAccount) {
                    makeDecreaseLiquidityInstructions.push(this.makeDecreaseLiquidityInstructions({
                        poolInfo,
                        ownerPosition: itemPosition,
                        ownerInfo: {
                            wallet: ownerInfo.wallet,
                            tokenAccountA: ownerTokenAccountA,
                            tokenAccountB: ownerTokenAccountB,
                            rewardAccounts
                        },
                        liquidity: entity_1.ZERO,
                        amountMinA: entity_1.ZERO,
                        amountMinB: entity_1.ZERO
                    }));
                }
            }
            const transactions = (0, common_1.splitTxAndSigners)({ instructions: makeDecreaseLiquidityInstructions.map(i => i.innerTransaction.instructions).flat(), signers: [], payer: ownerInfo.wallet });
            const innerTransactions = [];
            if (frontInstructions.length > 0)
                innerTransactions.push({
                    instructions: frontInstructions,
                    signers,
                    instructionTypes: frontInstructionsType,
                    supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                });
            innerTransactions.push(...transactions.map(i => ({
                instructions: i.instruction,
                signers: i.signer,
                instructionTypes: new Array(i.instruction.length).fill(base_1.InstructionType.clmmDecreasePosition),
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            })));
            if (endInstructions.length > 0)
                innerTransactions.push({
                    instructions: endInstructions,
                    signers: [],
                    instructionTypes: endInstructionsType,
                    supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                });
            return {
                address: {},
                innerTransactions
            };
        });
    }
    // instrument
    static makeCreatePoolInstructions({ connection, programId, owner, mintA, mintB, ammConfigId, initialPriceX64, startTime, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const observationId = new web3_js_1.Keypair();
            const poolId = (0, pda_2.getPdaPoolId)(programId, ammConfigId, mintA.mint, mintB.mint).publicKey;
            const mintAVault = (0, pda_2.getPdaPoolVaultId)(programId, poolId, mintA.mint).publicKey;
            const mintBVault = (0, pda_2.getPdaPoolVaultId)(programId, poolId, mintB.mint).publicKey;
            const instructions = [
                web3_js_1.SystemProgram.createAccount({
                    fromPubkey: owner,
                    newAccountPubkey: observationId.publicKey,
                    lamports: yield connection.getMinimumBalanceForRentExemption(layout_1.ObservationInfoLayout.span),
                    space: layout_1.ObservationInfoLayout.span,
                    programId,
                }),
                (0, instrument_2.createPoolInstruction)(programId, poolId, owner, ammConfigId, observationId.publicKey, mintA.mint, mintAVault, mintB.mint, mintBVault, initialPriceX64, startTime)
            ];
            return {
                address: {
                    observationId: observationId.publicKey,
                    poolId,
                    mintAVault,
                    mintBVault
                },
                innerTransaction: {
                    instructions,
                    signers: [observationId],
                    instructionTypes: [base_1.InstructionType.createAccount, base_1.InstructionType.clmmCreatePool],
                    supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                }
            };
        });
    }
    static makeOpenPositionInstructions({ poolInfo, ownerInfo, tickLower, tickUpper, liquidity, amountSlippageA, amountSlippageB }) {
        const nftMintAKeypair = new web3_js_1.Keypair();
        const tickArrayLowerStartIndex = tick_1.TickUtils.getTickArrayStartIndexByTick(tickLower, poolInfo.ammConfig.tickSpacing);
        const tickArrayUpperStartIndex = tick_1.TickUtils.getTickArrayStartIndexByTick(tickUpper, poolInfo.ammConfig.tickSpacing);
        const { publicKey: tickArrayLower } = (0, pda_2.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, tickArrayLowerStartIndex);
        const { publicKey: tickArrayUpper } = (0, pda_2.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, tickArrayUpperStartIndex);
        const { publicKey: positionNftAccount } = (0, pda_1.getATAAddress)(ownerInfo.wallet, nftMintAKeypair.publicKey);
        const { publicKey: metadataAccount } = (0, pda_2.getPdaMetadataKey)(nftMintAKeypair.publicKey);
        const { publicKey: personalPosition } = (0, pda_2.getPdaPersonalPositionAddress)(poolInfo.programId, nftMintAKeypair.publicKey);
        const { publicKey: protocolPosition } = (0, pda_2.getPdaProtocolPositionAddress)(poolInfo.programId, poolInfo.id, tickLower, tickUpper);
        const ins = (0, instrument_2.openPositionInstruction)(poolInfo.programId, ownerInfo.feePayer, poolInfo.id, ownerInfo.wallet, nftMintAKeypair.publicKey, positionNftAccount, metadataAccount, protocolPosition, tickArrayLower, tickArrayUpper, personalPosition, ownerInfo.tokenAccountA, ownerInfo.tokenAccountB, poolInfo.mintA.vault, poolInfo.mintB.vault, tickLower, tickUpper, tickArrayLowerStartIndex, tickArrayUpperStartIndex, liquidity, amountSlippageA, amountSlippageB);
        return {
            address: {
                nftMint: nftMintAKeypair.publicKey,
                tickArrayLower,
                tickArrayUpper,
                positionNftAccount,
                metadataAccount,
                personalPosition,
                protocolPosition,
            },
            innerTransaction: {
                instructions: [ins],
                signers: [nftMintAKeypair],
                instructionTypes: [base_1.InstructionType.clmmOpenPosition],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeIncreaseLiquidityInstructions({ poolInfo, ownerPosition, ownerInfo, liquidity, amountSlippageA, amountSlippageB }) {
        const tickArrayLowerStartIndex = tick_1.TickUtils.getTickArrayStartIndexByTick(ownerPosition.tickLower, poolInfo.ammConfig.tickSpacing);
        const tickArrayUpperStartIndex = tick_1.TickUtils.getTickArrayStartIndexByTick(ownerPosition.tickUpper, poolInfo.ammConfig.tickSpacing);
        const { publicKey: tickArrayLower } = (0, pda_2.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, tickArrayLowerStartIndex);
        const { publicKey: tickArrayUpper } = (0, pda_2.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, tickArrayUpperStartIndex);
        const { publicKey: positionNftAccount } = (0, pda_1.getATAAddress)(ownerInfo.wallet, ownerPosition.nftMint);
        const { publicKey: personalPosition } = (0, pda_2.getPdaPersonalPositionAddress)(poolInfo.programId, ownerPosition.nftMint);
        const { publicKey: protocolPosition } = (0, pda_2.getPdaProtocolPositionAddress)(poolInfo.programId, poolInfo.id, ownerPosition.tickLower, ownerPosition.tickUpper);
        return {
            address: {
                tickArrayLower,
                tickArrayUpper,
                positionNftAccount,
                personalPosition,
                protocolPosition,
            },
            innerTransaction: {
                instructions: [
                    (0, instrument_2.increaseLiquidityInstruction)(poolInfo.programId, ownerInfo.wallet, positionNftAccount, personalPosition, poolInfo.id, protocolPosition, tickArrayLower, tickArrayUpper, ownerInfo.tokenAccountA, ownerInfo.tokenAccountB, poolInfo.mintA.vault, poolInfo.mintB.vault, liquidity, amountSlippageA, amountSlippageB)
                ],
                signers: [],
                instructionTypes: [base_1.InstructionType.clmmIncreasePosition],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeDecreaseLiquidityInstructions({ poolInfo, ownerPosition, ownerInfo, liquidity, amountMinA, amountMinB }) {
        const tickArrayLowerStartIndex = tick_1.TickUtils.getTickArrayStartIndexByTick(ownerPosition.tickLower, poolInfo.ammConfig.tickSpacing);
        const tickArrayUpperStartIndex = tick_1.TickUtils.getTickArrayStartIndexByTick(ownerPosition.tickUpper, poolInfo.ammConfig.tickSpacing);
        const { publicKey: tickArrayLower } = (0, pda_2.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, tickArrayLowerStartIndex);
        const { publicKey: tickArrayUpper } = (0, pda_2.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, tickArrayUpperStartIndex);
        const { publicKey: positionNftAccount } = (0, pda_1.getATAAddress)(ownerInfo.wallet, ownerPosition.nftMint);
        const { publicKey: personalPosition } = (0, pda_2.getPdaPersonalPositionAddress)(poolInfo.programId, ownerPosition.nftMint);
        const { publicKey: protocolPosition } = (0, pda_2.getPdaProtocolPositionAddress)(poolInfo.programId, poolInfo.id, ownerPosition.tickLower, ownerPosition.tickUpper);
        const rewardAccounts = [];
        for (let i = 0; i < poolInfo.rewardInfos.length; i++) {
            rewardAccounts.push({
                poolRewardVault: poolInfo.rewardInfos[i].tokenVault,
                ownerRewardVault: ownerInfo.rewardAccounts[i]
            });
        }
        return {
            address: {
                tickArrayLower,
                tickArrayUpper,
                positionNftAccount,
                personalPosition,
                protocolPosition,
            },
            innerTransaction: {
                instructions: [
                    (0, instrument_2.decreaseLiquidityInstruction)(poolInfo.programId, ownerInfo.wallet, positionNftAccount, personalPosition, poolInfo.id, protocolPosition, tickArrayLower, tickArrayUpper, ownerInfo.tokenAccountA, ownerInfo.tokenAccountB, poolInfo.mintA.vault, poolInfo.mintB.vault, rewardAccounts, liquidity, amountMinA, amountMinB)
                ],
                signers: [],
                instructionTypes: [base_1.InstructionType.clmmDecreasePosition],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeClosePositionInstructions({ poolInfo, ownerInfo, ownerPosition }) {
        const { publicKey: positionNftAccount } = (0, pda_1.getATAAddress)(ownerInfo.wallet, ownerPosition.nftMint);
        const { publicKey: personalPosition } = (0, pda_2.getPdaPersonalPositionAddress)(poolInfo.programId, ownerPosition.nftMint);
        return {
            address: {
                positionNftAccount,
                personalPosition,
            },
            innerTransaction: {
                instructions: [
                    (0, instrument_2.closePositionInstruction)(poolInfo.programId, ownerInfo.wallet, ownerPosition.nftMint, positionNftAccount, personalPosition)
                ],
                signers: [],
                instructionTypes: [base_1.InstructionType.clmmClosePosition],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeSwapBaseInInstructions({ poolInfo, ownerInfo, inputMint, amountIn, amountOutMin, sqrtPriceLimitX64, remainingAccounts }) {
        const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
        return {
            address: {},
            innerTransaction: {
                instructions: [
                    (0, instrument_2.swapInstruction)(poolInfo.programId, ownerInfo.wallet, poolInfo.id, poolInfo.ammConfig.id, isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB, isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA, isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault, isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault, remainingAccounts, poolInfo.observationId, amountIn, amountOutMin, sqrtPriceLimitX64, true)
                ],
                signers: [],
                lookupTableAddress: [poolInfo.lookupTableAccount],
                instructionTypes: [base_1.InstructionType.clmmSwapBaseIn],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeSwapBaseOutInstructions({ poolInfo, ownerInfo, outputMint, amountOut, amountInMax, sqrtPriceLimitX64, remainingAccounts }) {
        const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
        return {
            address: {},
            innerTransaction: {
                instructions: [
                    (0, instrument_2.swapInstruction)(poolInfo.programId, ownerInfo.wallet, poolInfo.id, poolInfo.ammConfig.id, isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA, isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB, isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault, isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault, remainingAccounts, poolInfo.observationId, amountOut, amountInMax, sqrtPriceLimitX64, false),
                ],
                signers: [],
                lookupTableAddress: [poolInfo.lookupTableAccount],
                instructionTypes: [base_1.InstructionType.clmmSwapBaseOut],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeInitRewardInstructions({ poolInfo, ownerInfo, rewardInfo }) {
        const poolRewardVault = (0, pda_2.getPdaPoolRewardVaulId)(poolInfo.programId, poolInfo.id, rewardInfo.mint).publicKey;
        const operationId = (0, pda_2.getPdaOperationAccount)(poolInfo.programId).publicKey;
        return {
            address: { poolRewardVault, operationId },
            innerTransaction: {
                instructions: [
                    (0, instrument_2.initRewardInstruction)(poolInfo.programId, ownerInfo.wallet, poolInfo.id, operationId, poolInfo.ammConfig.id, ownerInfo.tokenAccount, rewardInfo.mint, poolRewardVault, rewardInfo.openTime, rewardInfo.endTime, rewardInfo.emissionsPerSecondX64),
                ],
                signers: [],
                instructionTypes: [base_1.InstructionType.clmmInitReward],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeSetRewardInstructions({ poolInfo, ownerInfo, rewardInfo }) {
        let rewardIndex;
        let rewardVault;
        for (let index = 0; index < poolInfo.rewardInfos.length; index++)
            if (poolInfo.rewardInfos[index].tokenMint.equals(rewardInfo.mint)) {
                rewardIndex = index;
                rewardVault = poolInfo.rewardInfos[index].tokenVault;
            }
        logger.assertArgument(rewardIndex !== undefined && rewardVault !== undefined, "reward mint check error", "no reward mint", poolInfo.rewardInfos);
        const operationId = (0, pda_2.getPdaOperationAccount)(poolInfo.programId).publicKey;
        return {
            address: { rewardVault, operationId },
            innerTransaction: {
                instructions: [
                    (0, instrument_2.setRewardInstruction)(poolInfo.programId, ownerInfo.wallet, poolInfo.id, operationId, poolInfo.ammConfig.id, ownerInfo.tokenAccount, rewardVault, rewardIndex, rewardInfo.openTime, rewardInfo.endTime, rewardInfo.emissionsPerSecondX64)
                ],
                signers: [],
                instructionTypes: [base_1.InstructionType.clmmInitReward],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    static makeCollectRewardInstructions({ poolInfo, ownerInfo, rewardMint }) {
        let rewardIndex;
        let rewardVault;
        for (let index = 0; index < poolInfo.rewardInfos.length; index++)
            if (poolInfo.rewardInfos[index].tokenMint.equals(rewardMint)) {
                rewardIndex = index;
                rewardVault = poolInfo.rewardInfos[index].tokenVault;
            }
        logger.assertArgument(rewardIndex !== undefined && rewardVault !== undefined, "reward mint check error", "no reward mint", poolInfo.rewardInfos);
        return {
            address: { rewardVault },
            innerTransaction: {
                instructions: [
                    (0, instrument_2.collectRewardInstruction)(poolInfo.programId, ownerInfo.wallet, poolInfo.id, ownerInfo.tokenAccount, rewardVault, rewardIndex)
                ],
                signers: [],
                instructionTypes: [base_1.InstructionType.clmmInitReward],
                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
            }
        };
    }
    // calculate
    static getLiquidityAmountOutFromAmountIn({ poolInfo, inputA, tickLower, tickUpper, amount, slippage, add }) {
        const sqrtPriceX64 = poolInfo.sqrtPriceX64;
        const sqrtPriceX64A = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(tickLower);
        const sqrtPriceX64B = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(tickUpper);
        const coefficient = add ? 1 - slippage : 1 + slippage;
        const _amount = amount.mul(new bn_js_1.default(Math.floor(coefficient * 1000000))).div(new bn_js_1.default(1000000));
        let liquidity;
        if (sqrtPriceX64.lte(sqrtPriceX64A)) {
            liquidity = inputA ? math_1.LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, _amount, !add) : new bn_js_1.default(0);
        }
        else if (sqrtPriceX64.lte(sqrtPriceX64B)) {
            const liquidity0 = math_1.LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64, sqrtPriceX64B, _amount, !add);
            const liquidity1 = math_1.LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64, _amount);
            liquidity = inputA ? liquidity0 : liquidity1;
        }
        else {
            liquidity = inputA ? new bn_js_1.default(0) : math_1.LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, _amount);
        }
        const amountsSlippage = math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolInfo.sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, add, !add, slippage);
        const amounts = math_1.LiquidityMath.getAmountsFromLiquidity(poolInfo.sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, !add);
        return Object.assign(Object.assign({ liquidity }, amountsSlippage), amounts);
    }
    static getLiquidityFromAmounts({ poolInfo, tickLower, tickUpper, amountA, amountB, slippage, add }) {
        const [_tickLower, _tickUpper, _amountA, _amountB] = tickLower < tickUpper ? [tickLower, tickUpper, amountA, amountB] : [tickUpper, tickLower, amountB, amountA];
        const sqrtPriceX64 = poolInfo.sqrtPriceX64;
        const sqrtPriceX64A = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(_tickLower);
        const sqrtPriceX64B = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(_tickUpper);
        const liquidity = math_1.LiquidityMath.getLiquidityFromTokenAmounts(sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, _amountA, _amountB);
        const amountsSlippage = math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, add, !add, slippage);
        const amounts = math_1.LiquidityMath.getAmountsFromLiquidity(sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, !add);
        return Object.assign(Object.assign({ liquidity }, amountsSlippage), amounts);
    }
    static getAmountsFromLiquidity({ poolInfo, ownerPosition, liquidity, slippage, add }) {
        const sqrtPriceX64A = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(ownerPosition.tickLower);
        const sqrtPriceX64B = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(ownerPosition.tickUpper);
        return math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolInfo.sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, add, add, slippage);
    }
    static getPriceAndTick({ poolInfo, price, baseIn }) {
        const _price = baseIn ? price : new decimal_js_1.default(1).div(price);
        const tick = math_1.TickMath.getTickWithPriceAndTickspacing(_price, poolInfo.ammConfig.tickSpacing, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
        const tickSqrtPriceX64 = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(tick);
        const tickPrice = math_1.SqrtPriceMath.sqrtPriceX64ToPrice(tickSqrtPriceX64, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
        return baseIn ? { tick, price: tickPrice } : { tick, price: new decimal_js_1.default(1).div(tickPrice) };
    }
    static getTickPrice({ poolInfo, tick, baseIn }) {
        const tickSqrtPriceX64 = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(tick);
        const tickPrice = math_1.SqrtPriceMath.sqrtPriceX64ToPrice(tickSqrtPriceX64, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
        return baseIn ? { tick, price: tickPrice, tickSqrtPriceX64 } : { tick, price: new decimal_js_1.default(1).div(tickPrice), tickSqrtPriceX64 };
    }
    static computeAmountOutFormat({ poolInfo, tickArrayCache, amountIn, currencyOut, slippage }) {
        const amountInIsTokenAmount = amountIn instanceof entity_1.TokenAmount;
        const inputMint = (amountInIsTokenAmount ? amountIn.token : entity_1.Token.WSOL).mint;
        const _amountIn = amountIn.raw;
        const _slippage = slippage.numerator.toNumber() / slippage.denominator.toNumber();
        const { amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee, remainingAccounts } = AmmV3.computeAmountOut({
            poolInfo,
            tickArrayCache,
            baseMint: inputMint,
            amountIn: _amountIn,
            slippage: _slippage,
        });
        const _amountOut = currencyOut instanceof entity_1.Token ? new entity_1.TokenAmount(currencyOut, amountOut) : new entity_1.CurrencyAmount(currencyOut, amountOut);
        const _minAmountOut = currencyOut instanceof entity_1.Token ? new entity_1.TokenAmount(currencyOut, minAmountOut) : new entity_1.CurrencyAmount(currencyOut, minAmountOut);
        const _currentPrice = new entity_1.Price(amountInIsTokenAmount ? amountIn.token : amountIn.currency, new bn_js_1.default(10).pow(new bn_js_1.default(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)), currencyOut instanceof entity_1.Token ? currencyOut : entity_1.Token.WSOL, currentPrice.mul(new decimal_js_1.default(10 ** (20 + (currencyOut instanceof entity_1.Token ? currencyOut : entity_1.Token.WSOL).decimals))).toFixed(0));
        const _executionPrice = new entity_1.Price(amountInIsTokenAmount ? amountIn.token : amountIn.currency, new bn_js_1.default(10).pow(new bn_js_1.default(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)), currencyOut instanceof entity_1.Token ? currencyOut : entity_1.Token.WSOL, executionPrice.mul(new decimal_js_1.default(10 ** (20 + (currencyOut instanceof entity_1.Token ? currencyOut : entity_1.Token.WSOL).decimals))).toFixed(0));
        const _fee = amountInIsTokenAmount ? new entity_1.TokenAmount(amountIn.token, fee) : new entity_1.CurrencyAmount(amountIn.currency, fee);
        return {
            amountOut: _amountOut,
            minAmountOut: _minAmountOut,
            currentPrice: _currentPrice,
            executionPrice: _executionPrice,
            priceImpact,
            fee: _fee,
            remainingAccounts
        };
    }
    static computeAmountOut({ poolInfo, tickArrayCache, baseMint, amountIn, slippage, priceLimit = new decimal_js_1.default(0) }) {
        let sqrtPriceLimitX64;
        if (priceLimit.equals(new decimal_js_1.default(0))) {
            sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintA.mint)
                ? constants_1.MIN_SQRT_PRICE_X64.add(entity_1.ONE)
                : constants_1.MAX_SQRT_PRICE_X64.sub(entity_1.ONE);
        }
        else {
            sqrtPriceLimitX64 = math_1.SqrtPriceMath.priceToSqrtPriceX64(priceLimit, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
        }
        const { expectedAmountOut, remainingAccounts, executionPrice: _executionPriceX64, feeAmount } = pool_1.PoolUtils.getOutputAmountAndRemainAccounts(poolInfo, tickArrayCache, baseMint, amountIn, sqrtPriceLimitX64);
        const _executionPrice = math_1.SqrtPriceMath.sqrtPriceX64ToPrice(_executionPriceX64, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
        const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new decimal_js_1.default(1).div(_executionPrice);
        const minAmountOut = expectedAmountOut.mul(new bn_js_1.default(Math.floor((1 - slippage) * 10000000000))).div(new bn_js_1.default(10000000000));
        const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new decimal_js_1.default(1).div(poolInfo.currentPrice);
        const _numerator = new decimal_js_1.default(executionPrice).sub(poolPrice).abs();
        const _denominator = poolPrice;
        const priceImpact = new entity_1.Percent(new decimal_js_1.default(_numerator).mul(10 ** 15).toFixed(0), new decimal_js_1.default(_denominator).mul(10 ** 15).toFixed(0));
        return {
            amountOut: expectedAmountOut,
            minAmountOut,
            currentPrice: poolInfo.currentPrice,
            executionPrice,
            priceImpact,
            fee: feeAmount,
            remainingAccounts
        };
    }
    static computeAmountIn({ poolInfo, tickArrayCache, baseMint, amountOut, slippage, priceLimit = new decimal_js_1.default(0) }) {
        let sqrtPriceLimitX64;
        if (priceLimit.equals(new decimal_js_1.default(0))) {
            sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintB.mint)
                ? constants_1.MIN_SQRT_PRICE_X64.add(entity_1.ONE)
                : constants_1.MAX_SQRT_PRICE_X64.sub(entity_1.ONE);
        }
        else {
            sqrtPriceLimitX64 = math_1.SqrtPriceMath.priceToSqrtPriceX64(priceLimit, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
        }
        const { expectedAmountIn, remainingAccounts, executionPrice: _executionPriceX64, feeAmount } = pool_1.PoolUtils.getInputAmountAndRemainAccounts(poolInfo, tickArrayCache, baseMint, amountOut, sqrtPriceLimitX64);
        const _executionPrice = math_1.SqrtPriceMath.sqrtPriceX64ToPrice(_executionPriceX64, poolInfo.mintA.decimals, poolInfo.mintB.decimals);
        const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new decimal_js_1.default(1).div(_executionPrice);
        const maxAmountIn = expectedAmountIn.mul(new bn_js_1.default(Math.floor((1 + slippage) * 10000000000))).div(new bn_js_1.default(10000000000));
        const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new decimal_js_1.default(1).div(poolInfo.currentPrice);
        const _numerator = new decimal_js_1.default(executionPrice).sub(poolPrice).abs();
        const _denominator = poolPrice;
        const priceImpact = new entity_1.Percent(new decimal_js_1.default(_numerator).mul(10 ** 15).toFixed(0), new decimal_js_1.default(_denominator).mul(10 ** 15).toFixed(0));
        return {
            amountIn: expectedAmountIn,
            maxAmountIn,
            currentPrice: poolInfo.currentPrice,
            executionPrice,
            priceImpact,
            fee: feeAmount,
            remainingAccounts
        };
    }
    static estimateAprsForPriceRangeMultiplier({ poolInfo, aprType, positionTickLowerIndex, positionTickUpperIndex }) {
        const aprInfo = poolInfo[aprType];
        const priceLower = this.getTickPrice({ poolInfo, tick: positionTickLowerIndex, baseIn: true }).price.toNumber();
        const priceUpper = this.getTickPrice({ poolInfo, tick: positionTickUpperIndex, baseIn: true }).price.toNumber();
        const _minPrice = Math.max(priceLower, aprInfo.priceMin);
        const _maxPrice = Math.min(priceUpper, aprInfo.priceMax);
        const sub = _maxPrice - _minPrice;
        const userRange = priceUpper - priceLower;
        const tradeRange = aprInfo.priceMax - aprInfo.priceMin;
        let p;
        if (sub <= 0)
            p = 0;
        else if (userRange === sub)
            p = (tradeRange) / sub;
        else if (tradeRange === sub)
            p = sub / (userRange);
        else
            p = sub / (tradeRange) * (sub / (userRange));
        return {
            feeApr: aprInfo.feeApr * p,
            rewardsApr: [aprInfo.rewardApr.A * p, aprInfo.rewardApr.B * p, aprInfo.rewardApr.C * p],
            apr: aprInfo.apr * p
        };
    }
    static estimateAprsForPriceRangeDelta({ poolInfo, aprType, mintPrice, rewardMintDecimals, liquidity, positionTickLowerIndex, positionTickUpperIndex, chainTime }) {
        const aprTypeDay = aprType === 'day' ? 1 : aprType === 'week' ? 7 : aprType === 'month' ? 30 : 0;
        const aprInfo = poolInfo[aprType];
        const mintPriceA = mintPrice[poolInfo.mintA.mint.toString()];
        const mintPriceB = mintPrice[poolInfo.mintB.mint.toString()];
        const mintDecimalsA = poolInfo.mintA.decimals;
        const mintDecimalsB = poolInfo.mintB.decimals;
        if (!aprInfo || !mintPriceA || !mintPriceB)
            return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
        const sqrtPriceX64A = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(positionTickLowerIndex);
        const sqrtPriceX64B = math_1.SqrtPriceMath.getSqrtPriceX64FromTick(positionTickUpperIndex);
        const { amountSlippageA: poolLiquidityA, amountSlippageB: poolLiquidityB } = math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolInfo.sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, poolInfo.liquidity, false, false, 0);
        const { amountSlippageA: userLiquidityA, amountSlippageB: userLiquidityB } = math_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolInfo.sqrtPriceX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, false, false, 0);
        const poolTvl = new decimal_js_1.default(poolLiquidityA.toString()).div(new decimal_js_1.default(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(new decimal_js_1.default(poolLiquidityB.toString()).div(new decimal_js_1.default(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB)));
        const userTvl = new decimal_js_1.default(userLiquidityA.toString()).div(new decimal_js_1.default(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(new decimal_js_1.default(userLiquidityB.toString()).div(new decimal_js_1.default(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB)));
        const p = userTvl.div(poolTvl.add(userTvl)).div(userTvl);
        const feesPerYear = new decimal_js_1.default(aprInfo.volumeFee).mul(365).div(aprTypeDay);
        const feeApr = feesPerYear.mul(p).mul(100).toNumber();
        const SECONDS_PER_YEAR = 3600 * 24 * 365;
        const rewardsApr = poolInfo.rewardInfos.map((i) => {
            const iDecimal = rewardMintDecimals[i.tokenMint.toString()];
            const iPrice = mintPrice[i.tokenMint.toString()];
            if (chainTime < i.openTime.toNumber() || chainTime > i.endTime.toNumber() || i.perSecond.equals(0) || !iPrice || iDecimal === undefined)
                return 0;
            return new decimal_js_1.default(iPrice.toFixed(iDecimal)).mul(i.perSecond.mul(SECONDS_PER_YEAR)).div(new decimal_js_1.default(10).pow(iDecimal)).mul(p).mul(100).toNumber();
        });
        return {
            feeApr,
            rewardsApr,
            apr: feeApr + rewardsApr.reduce((a, b) => a + b, 0)
        };
    }
    // fetch data
    static fetchMultiplePoolInfos({ connection, poolKeys, ownerInfo, chainTime, batchRequest = false }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const poolAccountInfos = yield (0, common_1.getMultipleAccountsInfo)(connection, poolKeys.map(i => new web3_js_1.PublicKey(i.id)), { batchRequest });
            const programIds = [];
            const poolsInfo = {};
            const updateRewardInfos = [];
            for (let index = 0; index < poolKeys.length; index++) {
                const apiPoolInfo = poolKeys[index];
                const accountInfo = poolAccountInfos[index];
                if (accountInfo === null)
                    continue;
                const layoutAccountInfo = layout_1.PoolInfoLayout.decode(accountInfo.data);
                poolsInfo[apiPoolInfo.id] = {
                    state: {
                        id: new web3_js_1.PublicKey(apiPoolInfo.id),
                        mintA: {
                            mint: layoutAccountInfo.mintA,
                            vault: layoutAccountInfo.vaultA,
                            decimals: layoutAccountInfo.mintDecimalsA,
                        },
                        mintB: {
                            mint: layoutAccountInfo.mintB,
                            vault: layoutAccountInfo.vaultB,
                            decimals: layoutAccountInfo.mintDecimalsB,
                        },
                        observationId: layoutAccountInfo.observationId,
                        ammConfig: Object.assign(Object.assign({}, apiPoolInfo.ammConfig), { id: new web3_js_1.PublicKey(apiPoolInfo.ammConfig.id) }),
                        creator: layoutAccountInfo.creator,
                        programId: accountInfo.owner,
                        version: 6,
                        tickSpacing: layoutAccountInfo.tickSpacing,
                        liquidity: layoutAccountInfo.liquidity,
                        sqrtPriceX64: layoutAccountInfo.sqrtPriceX64,
                        currentPrice: math_1.SqrtPriceMath.sqrtPriceX64ToPrice(layoutAccountInfo.sqrtPriceX64, layoutAccountInfo.mintDecimalsA, layoutAccountInfo.mintDecimalsB),
                        tickCurrent: layoutAccountInfo.tickCurrent,
                        observationIndex: layoutAccountInfo.observationIndex,
                        observationUpdateDuration: layoutAccountInfo.observationUpdateDuration,
                        feeGrowthGlobalX64A: layoutAccountInfo.feeGrowthGlobalX64A,
                        feeGrowthGlobalX64B: layoutAccountInfo.feeGrowthGlobalX64B,
                        protocolFeesTokenA: layoutAccountInfo.protocolFeesTokenA,
                        protocolFeesTokenB: layoutAccountInfo.protocolFeesTokenB,
                        swapInAmountTokenA: layoutAccountInfo.swapInAmountTokenA,
                        swapOutAmountTokenB: layoutAccountInfo.swapOutAmountTokenB,
                        swapInAmountTokenB: layoutAccountInfo.swapInAmountTokenB,
                        swapOutAmountTokenA: layoutAccountInfo.swapOutAmountTokenA,
                        tickArrayBitmap: layoutAccountInfo.tickArrayBitmap,
                        rewardInfos: pool_1.PoolUtils.updatePoolRewardInfos({
                            chainTime,
                            poolLiquidity: layoutAccountInfo.liquidity,
                            rewardInfos: layoutAccountInfo.rewardInfos.filter(i => !i.tokenMint.equals(web3_js_1.PublicKey.default))
                        }),
                        day: apiPoolInfo.day,
                        week: apiPoolInfo.week,
                        month: apiPoolInfo.month,
                        tvl: apiPoolInfo.tvl,
                        lookupTableAccount: new web3_js_1.PublicKey(apiPoolInfo.lookupTableAccount),
                        startTime: layoutAccountInfo.startTime.toNumber(),
                    }
                };
                if (ownerInfo) {
                    updateRewardInfos.push(...poolsInfo[apiPoolInfo.id].state.rewardInfos.filter(i => i.creator.equals(ownerInfo.wallet)));
                }
                if (!programIds.find(i => i.equals(accountInfo.owner)))
                    programIds.push(accountInfo.owner);
            }
            if (ownerInfo) {
                const allMint = ownerInfo.tokenAccounts.filter(i => i.accountInfo.amount.eq(new bn_js_1.default(1))).map(i => i.accountInfo.mint);
                const allPositionKey = [];
                for (const itemMint of allMint) {
                    for (const itemProgramId of programIds) {
                        allPositionKey.push((0, pda_2.getPdaPersonalPositionAddress)(itemProgramId, itemMint).publicKey);
                    }
                }
                const positionAccountInfos = yield (0, common_1.getMultipleAccountsInfo)(connection, allPositionKey, { batchRequest });
                const keyToTickArrayAddress = {};
                for (const itemAccountInfo of positionAccountInfos) {
                    if (itemAccountInfo === null)
                        continue;
                    const position = layout_1.PositionInfoLayout.decode(itemAccountInfo.data);
                    const itemPoolId = position.poolId.toString();
                    const poolInfoA = poolsInfo[itemPoolId];
                    if (poolInfoA === undefined)
                        continue;
                    const poolInfo = poolInfoA.state;
                    const priceLower = this.getTickPrice({
                        poolInfo,
                        tick: position.tickLower,
                        baseIn: true
                    });
                    const priceUpper = this.getTickPrice({
                        poolInfo,
                        tick: position.tickUpper,
                        baseIn: true
                    });
                    const { amountA, amountB } = math_1.LiquidityMath.getAmountsFromLiquidity(poolInfo.sqrtPriceX64, priceLower.tickSqrtPriceX64, priceUpper.tickSqrtPriceX64, position.liquidity, false);
                    const leverage = 1 / (1 - Math.sqrt(Math.sqrt(priceLower.price.div(priceUpper.price).toNumber())));
                    poolsInfo[itemPoolId].positionAccount = [...((_a = poolsInfo[itemPoolId].positionAccount) !== null && _a !== void 0 ? _a : []), {
                            poolId: position.poolId,
                            nftMint: position.nftMint,
                            priceLower: priceLower.price,
                            priceUpper: priceUpper.price,
                            amountA,
                            amountB,
                            tickLower: position.tickLower,
                            tickUpper: position.tickUpper,
                            liquidity: position.liquidity,
                            feeGrowthInsideLastX64A: position.feeGrowthInsideLastX64A,
                            feeGrowthInsideLastX64B: position.feeGrowthInsideLastX64B,
                            tokenFeesOwedA: position.tokenFeesOwedA,
                            tokenFeesOwedB: position.tokenFeesOwedB,
                            rewardInfos: position.rewardInfos.map(i => (Object.assign(Object.assign({}, i), { pendingReward: new bn_js_1.default(0) }))),
                            leverage,
                            tokenFeeAmountA: new bn_js_1.default(0),
                            tokenFeeAmountB: new bn_js_1.default(0),
                        }];
                    const tickArrayLowerAddress = tick_1.TickUtils.getTickArrayAddressByTick(poolsInfo[itemPoolId].state.programId, position.poolId, position.tickLower, poolsInfo[itemPoolId].state.tickSpacing);
                    const tickArrayUpperAddress = tick_1.TickUtils.getTickArrayAddressByTick(poolsInfo[itemPoolId].state.programId, position.poolId, position.tickUpper, poolsInfo[itemPoolId].state.tickSpacing);
                    keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickLower}`] = tickArrayLowerAddress;
                    keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickUpper}`] = tickArrayUpperAddress;
                }
                const tickArrayKeys = Object.values(keyToTickArrayAddress);
                const tickArrayDatas = yield (0, common_1.getMultipleAccountsInfo)(connection, tickArrayKeys, { batchRequest });
                const tickArrayLayout = {};
                for (let index = 0; index < tickArrayKeys.length; index++) {
                    const tickArrayData = tickArrayDatas[index];
                    if (tickArrayData === null)
                        continue;
                    const key = tickArrayKeys[index].toString();
                    tickArrayLayout[key] = layout_1.TickArrayLayout.decode(tickArrayData.data);
                }
                for (const { state, positionAccount } of Object.values(poolsInfo)) {
                    if (!positionAccount)
                        continue;
                    for (const itemPA of positionAccount) {
                        const keyLower = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickLower}`;
                        const keyUpper = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickUpper}`;
                        const tickArrayLower = tickArrayLayout[keyToTickArrayAddress[keyLower].toString()];
                        const tickArrayUpper = tickArrayLayout[keyToTickArrayAddress[keyUpper].toString()];
                        const tickLowerState = tickArrayLower.ticks[tick_1.TickUtils.getTickOffsetInArray(itemPA.tickLower, state.tickSpacing)];
                        const tickUpperState = tickArrayUpper.ticks[tick_1.TickUtils.getTickOffsetInArray(itemPA.tickUpper, state.tickSpacing)];
                        const { tokenFeeAmountA, tokenFeeAmountB } = position_1.PositionUtils.GetPositionFees(state, itemPA, tickLowerState, tickUpperState);
                        const rewardInfos = position_1.PositionUtils.GetPositionRewards(state, itemPA, tickLowerState, tickUpperState);
                        itemPA.tokenFeeAmountA = tokenFeeAmountA.gte(entity_1.ZERO) ? tokenFeeAmountA : entity_1.ZERO;
                        itemPA.tokenFeeAmountB = tokenFeeAmountB.gte(entity_1.ZERO) ? tokenFeeAmountB : entity_1.ZERO;
                        for (let i = 0; i < rewardInfos.length; i++) {
                            itemPA.rewardInfos[i].pendingReward = rewardInfos[i].gte(entity_1.ZERO) ? rewardInfos[i] : entity_1.ZERO;
                        }
                    }
                }
            }
            if (updateRewardInfos.length > 0) {
                const vaults = updateRewardInfos.map(i => i.tokenVault);
                const rewardVaultInfos = yield (0, common_1.getMultipleAccountsInfo)(connection, vaults, { batchRequest });
                const rewardVaultAmount = {};
                for (let index = 0; index < vaults.length; index++) {
                    const valutKey = vaults[index].toString();
                    const itemRewardVaultInfo = rewardVaultInfos[index];
                    if (itemRewardVaultInfo === null)
                        continue;
                    const info = spl_1.SPL_ACCOUNT_LAYOUT.decode(itemRewardVaultInfo.data);
                    rewardVaultAmount[valutKey] = info.amount;
                }
                for (const item of updateRewardInfos) {
                    const vaultAmount = rewardVaultAmount[item.tokenVault.toString()];
                    item.remainingRewards = vaultAmount !== undefined ? vaultAmount.sub(item.rewardTotalEmissioned) : entity_1.ZERO;
                }
            }
            return poolsInfo;
        });
    }
    static fetchMultiplePoolTickArrays({ connection, poolKeys, batchRequest }) {
        return __awaiter(this, void 0, void 0, function* () {
            const tickArraysToPoolId = {};
            const tickArrays = [];
            for (const itemPoolInfo of poolKeys) {
                const tickArrayBitmap = tick_1.TickUtils.mergeTickArrayBitmap(itemPoolInfo.tickArrayBitmap);
                const currentTickArrayStartIndex = tick_1.TickUtils.getTickArrayStartIndexByTick(itemPoolInfo.tickCurrent, itemPoolInfo.tickSpacing);
                const startIndexArray = tick_1.TickUtils.getInitializedTickArrayInRange(tickArrayBitmap, itemPoolInfo.tickSpacing, currentTickArrayStartIndex, Math.floor(tickQuery_1.FETCH_TICKARRAY_COUNT / 2));
                for (const itemIndex of startIndexArray) {
                    const { publicKey: tickArrayAddress } = (0, pda_2.getPdaTickArrayAddress)(itemPoolInfo.programId, itemPoolInfo.id, itemIndex);
                    tickArrays.push({ pubkey: tickArrayAddress });
                    tickArraysToPoolId[tickArrayAddress.toString()] = itemPoolInfo.id;
                }
            }
            const fetchedTickArrays = (yield (0, common_1.getMultipleAccountsInfoWithCustomFlags)(connection, tickArrays, { batchRequest }));
            const tickArrayCache = {};
            for (const itemAccountInfo of fetchedTickArrays) {
                if (!itemAccountInfo.accountInfo)
                    continue;
                const poolId = tickArraysToPoolId[itemAccountInfo.pubkey.toString()];
                if (!poolId)
                    continue;
                if (tickArrayCache[poolId] === undefined)
                    tickArrayCache[poolId] = {};
                const accountLayoutData = layout_1.TickArrayLayout.decode(itemAccountInfo.accountInfo.data);
                tickArrayCache[poolId][accountLayoutData.startTickIndex] = Object.assign(Object.assign({}, accountLayoutData), { address: itemAccountInfo.pubkey });
            }
            return tickArrayCache;
        });
    }
    static getWhiteListMint({ connection, programId }) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountInfo = yield connection.getAccountInfo((0, pda_2.getPdaOperationAccount)(programId).publicKey);
            if (!accountInfo)
                return [];
            const whitelistMintsInfo = layout_1.OperationLayout.decode(accountInfo.data);
            return whitelistMintsInfo.whitelistMints.filter(i => !i.equals(web3_js_1.PublicKey.default));
        });
    }
}
exports.AmmV3 = AmmV3;
//# sourceMappingURL=ammV3.js.map