"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolUtils = void 0;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
const entity_1 = require("../../entity");
const constants_1 = require("./constants");
const math_1 = require("./math");
const pda_1 = require("./pda");
const tick_1 = require("./tick");
class PoolUtils {
    static getOutputAmountAndRemainAccounts(poolInfo, tickArrayCache, inputTokenMint, inputAmount, sqrtPriceLimitX64) {
        const zeroForOne = inputTokenMint.equals(poolInfo.mintA.mint);
        const allNeededAccounts = [];
        const { isExist, startIndex: firstTickArrayStartIndex, nextAccountMeta } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
        if (!isExist || firstTickArrayStartIndex === undefined || !nextAccountMeta)
            throw new Error("Invalid tick array");
        try {
            const preTick = this.preInitializedTickArrayStartIndex(poolInfo, !zeroForOne);
            if (preTick.isExist) {
                const { publicKey: address } = (0, pda_1.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
                allNeededAccounts.push(address);
            }
        }
        catch (e) { /* empty */ }
        allNeededAccounts.push(nextAccountMeta);
        const { amountCalculated: outputAmount, accounts: reaminAccounts, sqrtPriceX64: executionPrice, feeAmount } = math_1.SwapMath.swapCompute(poolInfo.programId, poolInfo.id, tickArrayCache, zeroForOne, poolInfo.ammConfig.tradeFeeRate, poolInfo.liquidity, poolInfo.tickCurrent, poolInfo.tickSpacing, poolInfo.sqrtPriceX64, inputAmount, firstTickArrayStartIndex, sqrtPriceLimitX64);
        allNeededAccounts.push(...reaminAccounts);
        return { expectedAmountOut: outputAmount.mul(constants_1.NEGATIVE_ONE), remainingAccounts: allNeededAccounts, executionPrice, feeAmount };
    }
    static getInputAmountAndRemainAccounts(poolInfo, tickArrayCache, outputTokenMint, outputAmount, sqrtPriceLimitX64) {
        const zeroForOne = outputTokenMint.equals(poolInfo.mintB.mint);
        const allNeededAccounts = [];
        const { isExist, startIndex: firstTickArrayStartIndex, nextAccountMeta } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
        if (!isExist || firstTickArrayStartIndex === undefined || !nextAccountMeta)
            throw new Error("Invalid tick array");
        try {
            const preTick = this.preInitializedTickArrayStartIndex(poolInfo, !zeroForOne);
            if (preTick.isExist) {
                const { publicKey: address } = (0, pda_1.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
                allNeededAccounts.push(address);
            }
        }
        catch (e) { /* empty */ }
        allNeededAccounts.push(nextAccountMeta);
        const { amountCalculated: inputAmount, accounts: reaminAccounts, sqrtPriceX64: executionPrice, feeAmount } = math_1.SwapMath.swapCompute(poolInfo.programId, poolInfo.id, tickArrayCache, zeroForOne, poolInfo.ammConfig.tradeFeeRate, poolInfo.liquidity, poolInfo.tickCurrent, poolInfo.tickSpacing, poolInfo.sqrtPriceX64, outputAmount.mul(constants_1.NEGATIVE_ONE), firstTickArrayStartIndex, sqrtPriceLimitX64);
        allNeededAccounts.push(...reaminAccounts);
        return { expectedAmountIn: inputAmount, remainingAccounts: allNeededAccounts, executionPrice, feeAmount };
    }
    static getFirstInitializedTickArray(poolInfo, zeroForOne) {
        const tickArrayBitmap = tick_1.TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap);
        const { isInitialized, startIndex } = tick_1.TickUtils.checkTickArrayIsInitialized(tickArrayBitmap, poolInfo.tickCurrent, poolInfo.tickSpacing);
        if (isInitialized) {
            const { publicKey: address } = (0, pda_1.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, startIndex);
            return {
                isExist: true,
                startIndex,
                nextAccountMeta: address
            };
        }
        const { isExist, nextStartIndex } = this.nextInitializedTickArrayStartIndex(poolInfo, zeroForOne);
        if (isExist) {
            const { publicKey: address } = (0, pda_1.getPdaTickArrayAddress)(poolInfo.programId, poolInfo.id, nextStartIndex);
            return {
                isExist: true,
                startIndex: nextStartIndex,
                nextAccountMeta: address
            };
        }
        return { isExist: false, nextAccountMeta: undefined, startIndex: undefined };
    }
    static preInitializedTickArrayStartIndex(poolInfo, zeroForOne) {
        const tickArrayBitmap = tick_1.TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap);
        const currentOffset = tick_1.TickUtils.getTickArrayOffsetInBitmapByTick(poolInfo.tickCurrent, poolInfo.tickSpacing);
        const result = zeroForOne ? tick_1.TickUtils.searchLowBitFromStart(tickArrayBitmap, currentOffset - 1, 0, 1, poolInfo.tickSpacing) : tick_1.TickUtils.searchHightBitFromStart(tickArrayBitmap, currentOffset + 1, 1024, 1, poolInfo.tickSpacing);
        return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
    }
    static nextInitializedTickArrayStartIndex(poolInfo, zeroForOne) {
        const tickArrayBitmap = tick_1.TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap);
        const currentOffset = tick_1.TickUtils.getTickArrayOffsetInBitmapByTick(poolInfo.tickCurrent, poolInfo.tickSpacing);
        const result = zeroForOne ? tick_1.TickUtils.searchLowBitFromStart(tickArrayBitmap, currentOffset - 1, 0, 1, poolInfo.tickSpacing) : tick_1.TickUtils.searchHightBitFromStart(tickArrayBitmap, currentOffset, 1024, 1, poolInfo.tickSpacing);
        return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
    }
    static updatePoolRewardInfos({ chainTime, poolLiquidity, rewardInfos }) {
        const nRewardInfo = [];
        for (const _itemReward of rewardInfos) {
            const itemReward = Object.assign(Object.assign({}, _itemReward), { perSecond: math_1.MathUtil.x64ToDecimal(_itemReward.emissionsPerSecondX64), remainingRewards: undefined });
            if (itemReward.tokenMint.equals(web3_js_1.PublicKey.default))
                continue;
            if (chainTime <= itemReward.openTime.toNumber() || poolLiquidity.eq(entity_1.ZERO)) {
                nRewardInfo.push(itemReward);
                continue;
            }
            const latestUpdateTime = new bn_js_1.default(Math.min(itemReward.endTime.toNumber(), chainTime));
            const timeDelta = latestUpdateTime.sub(itemReward.lastUpdateTime);
            const rewardGrowthDeltaX64 = math_1.MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, poolLiquidity);
            const rewardGrowthGlobalX64 = itemReward.rewardGrowthGlobalX64.add(rewardGrowthDeltaX64);
            const rewardEmissionedDelta = math_1.MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, constants_1.Q64);
            const rewardTotalEmissioned = itemReward.rewardTotalEmissioned.add(rewardEmissionedDelta);
            nRewardInfo.push(Object.assign(Object.assign({}, itemReward), { rewardGrowthGlobalX64,
                rewardTotalEmissioned, lastUpdateTime: latestUpdateTime }));
        }
        return nRewardInfo;
    }
}
exports.PoolUtils = PoolUtils;
//# sourceMappingURL=pool.js.map