"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const entity_1 = require("../entity");
const spl_1 = require("../spl");
const type_1 = require("./type");
class Base {
    static _selectTokenAccount(params) {
        const { tokenAccounts, mint, owner, config } = params;
        const { associatedOnly } = Object.assign({ associatedOnly: true }, config);
        const _tokenAccounts = tokenAccounts
            // filter by mint
            .filter(({ accountInfo }) => accountInfo.mint.equals(mint))
            // sort by balance
            .sort((a, b) => (a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1));
        const ata = spl_1.Spl.getAssociatedTokenAccount({ mint, owner });
        for (const tokenAccount of _tokenAccounts) {
            const { pubkey } = tokenAccount;
            if (associatedOnly) {
                // return ata only
                if (ata.equals(pubkey))
                    return pubkey;
            }
            else {
                // return the first account
                return pubkey;
            }
        }
        return null;
    }
    static _handleTokenAccount(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { connection, side, amount, mint, tokenAccount, owner, payer = owner, frontInstructions, endInstructions, signers, bypassAssociatedCheck, frontInstructionsType, endInstructionsType, } = params;
            const ata = spl_1.Spl.getAssociatedTokenAccount({ mint, owner });
            if (entity_1.Token.WSOL.mint.equals(mint)) {
                const newTokenAccount = yield spl_1.Spl.insertCreateWrappedNativeAccount({
                    connection,
                    owner,
                    payer,
                    instructions: frontInstructions,
                    instructionsType: frontInstructionsType,
                    signers,
                    amount,
                });
                // if no endInstructions provide, no need to close
                if (endInstructions) {
                    endInstructions.push(spl_1.Spl.makeCloseAccountInstruction({ tokenAccount: newTokenAccount, owner, payer, instructionsType: endInstructionsType !== null && endInstructionsType !== void 0 ? endInstructionsType : [] }));
                }
                return newTokenAccount;
            }
            else if (!tokenAccount || (side === "out" && !ata.equals(tokenAccount) && !bypassAssociatedCheck)) {
                frontInstructions.push(spl_1.Spl.makeCreateAssociatedTokenAccountInstruction({
                    mint,
                    associatedAccount: ata,
                    owner,
                    payer,
                    instructionsType: frontInstructionsType,
                }));
                return ata;
            }
            return tokenAccount;
        });
    }
    static _selectOrCreateTokenAccount(params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return __awaiter(this, void 0, void 0, function* () {
            const { mint, tokenAccounts, createInfo, associatedOnly, owner } = params;
            const ata = spl_1.Spl.getAssociatedTokenAccount({ mint, owner });
            const accounts = tokenAccounts.filter((i) => i.accountInfo.mint.equals(mint) && (!associatedOnly || i.pubkey.equals(ata))).sort((a, b) => (a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1));
            // find token or don't need create
            if (createInfo === undefined || accounts.length > 0) {
                return accounts.length > 0 ? accounts[0].pubkey : undefined;
            }
            if (associatedOnly) {
                createInfo.frontInstructions.push(spl_1.Spl.makeCreateAssociatedTokenAccountInstruction({
                    mint,
                    associatedAccount: ata,
                    owner,
                    payer: createInfo.payer,
                    instructionsType: createInfo.frontInstructionsType,
                }));
                if (mint.equals(entity_1.Token.WSOL.mint) && createInfo.amount) {
                    const newTokenAccount = yield spl_1.Spl.insertCreateWrappedNativeAccount({
                        connection: createInfo.connection,
                        owner,
                        payer: createInfo.payer,
                        instructions: createInfo.frontInstructions,
                        instructionsType: createInfo.frontInstructionsType,
                        signers: createInfo.signers,
                        amount: (_a = createInfo.amount) !== null && _a !== void 0 ? _a : 0,
                    });
                    ((_b = createInfo.endInstructions) !== null && _b !== void 0 ? _b : []).push(spl_1.Spl.makeCloseAccountInstruction({ tokenAccount: newTokenAccount, owner, payer: createInfo.payer, instructionsType: (_c = createInfo.endInstructionsType) !== null && _c !== void 0 ? _c : [] }));
                    if (createInfo.amount) {
                        createInfo.frontInstructions.push(spl_1.Spl.makeTransferInstruction({
                            source: newTokenAccount,
                            destination: ata,
                            owner,
                            amount: createInfo.amount,
                            instructionsType: createInfo.frontInstructionsType
                        }));
                    }
                }
                ((_d = createInfo.endInstructions) !== null && _d !== void 0 ? _d : []).push(spl_1.Spl.makeCloseAccountInstruction({ tokenAccount: ata, owner, payer: createInfo.payer, instructionsType: (_e = createInfo.endInstructionsType) !== null && _e !== void 0 ? _e : [] }));
                return ata;
            }
            else {
                if (mint.equals(entity_1.Token.WSOL.mint)) {
                    const newTokenAccount = yield spl_1.Spl.insertCreateWrappedNativeAccount({
                        connection: createInfo.connection,
                        owner,
                        payer: createInfo.payer,
                        instructions: createInfo.frontInstructions,
                        instructionsType: createInfo.frontInstructionsType,
                        signers: createInfo.signers,
                        amount: (_f = createInfo.amount) !== null && _f !== void 0 ? _f : 0,
                    });
                    ((_g = createInfo.endInstructions) !== null && _g !== void 0 ? _g : []).push(spl_1.Spl.makeCloseAccountInstruction({ tokenAccount: newTokenAccount, owner, payer: createInfo.payer, instructionsType: (_h = createInfo.endInstructionsType) !== null && _h !== void 0 ? _h : [] }));
                    return newTokenAccount;
                }
                else {
                    const newTokenAccount = web3_js_1.Keypair.generate();
                    const balanceNeeded = yield createInfo.connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
                    const createAccountIns = web3_js_1.SystemProgram.createAccount({
                        fromPubkey: owner,
                        newAccountPubkey: newTokenAccount.publicKey,
                        lamports: balanceNeeded,
                        space: spl_token_1.AccountLayout.span,
                        programId: spl_token_1.TOKEN_PROGRAM_ID,
                    });
                    const initAccountIns = spl_1.Spl.createInitAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, mint, newTokenAccount.publicKey, owner);
                    createInfo.frontInstructions.push(createAccountIns, initAccountIns);
                    createInfo.frontInstructionsType.push(type_1.InstructionType.createAccount, type_1.InstructionType.initAccount);
                    createInfo.signers.push(newTokenAccount);
                    ((_j = createInfo.endInstructions) !== null && _j !== void 0 ? _j : []).push(spl_1.Spl.makeCloseAccountInstruction({ tokenAccount: newTokenAccount.publicKey, owner, payer: createInfo.payer, instructionsType: (_k = createInfo.endInstructionsType) !== null && _k !== void 0 ? _k : [] }));
                    return newTokenAccount.publicKey;
                }
            }
        });
    }
}
exports.Base = Base;
//# sourceMappingURL=base.js.map