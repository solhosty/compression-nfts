"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildTransaction = exports.unwarpSol = exports.getWSOLAmount = void 0;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = require("bn.js");
const common_1 = require("../common");
const spl_1 = require("../spl");
const token_1 = require("../token");
const type_1 = require("./type");
function getWSOLAmount({ tokenAccounts }) {
    const WSOL_MINT = new web3_js_1.PublicKey(token_1.WSOL.mint);
    const amounts = tokenAccounts.filter(i => i.accountInfo.mint.equals(WSOL_MINT)).map(i => i.accountInfo.amount);
    const amount = amounts.reduce((a, b) => a.add(b), new bn_js_1.BN(0));
    return amount;
}
exports.getWSOLAmount = getWSOLAmount;
function unwarpSol({ ownerInfo, tokenAccounts }) {
    const WSOL_MINT = new web3_js_1.PublicKey(token_1.WSOL.mint);
    const instructionsInfo = tokenAccounts.filter(i => i.accountInfo.mint.equals(WSOL_MINT)).map(i => ({
        amount: i.accountInfo.amount,
        tx: spl_1.Spl.makeCloseAccountInstruction({ tokenAccount: i.pubkey, owner: ownerInfo.wallet, payer: ownerInfo.payer, instructionsType: [] })
    }));
    const transactions = (0, common_1.splitTxAndSigners)({ instructions: instructionsInfo.map(i => i.tx), signers: [], payer: ownerInfo.wallet });
    return {
        address: {},
        innerTransactions: transactions.map(i => ({
            instructions: i.instruction,
            signers: i.signer,
            lookupTableAddress: [],
            instructionTypes: new Array(i.instruction.length).fill('closeAccount'),
            supportedVersion: [type_1.TxVersion.LEGACY, type_1.TxVersion.V0]
        }))
    };
}
exports.unwarpSol = unwarpSol;
function buildTransaction({ connection, txType, payer, innerTransactions, recentBlockhash }) {
    return __awaiter(this, void 0, void 0, function* () {
        const _recentBlockhash = recentBlockhash !== null && recentBlockhash !== void 0 ? recentBlockhash : yield (yield connection.getLatestBlockhash()).blockhash;
        if (txType === type_1.TxVersion.V0) {
            const lookupTableAddress = innerTransactions.map(i => { var _a; return (_a = i.lookupTableAddress) !== null && _a !== void 0 ? _a : []; }).flat();
            const lookupTableAccounts = lookupTableAddress.length > 0 ? yield (0, common_1.getMultipleLookupTableInfo)({ connection, address: lookupTableAddress }) : [];
            const versionedTransaction = [];
            for (const itemInss of innerTransactions) {
                if (itemInss.supportedVersion.find(i => i === type_1.TxVersion.V0) === undefined)
                    throw Error('has error type transaction');
                const messageV0 = new web3_js_1.TransactionMessage({
                    payerKey: payer,
                    recentBlockhash: _recentBlockhash,
                    instructions: itemInss.instructions,
                }).compileToV0Message(lookupTableAccounts);
                const t = new web3_js_1.VersionedTransaction(messageV0);
                t.sign(itemInss.signers);
                versionedTransaction.push(t);
            }
            return versionedTransaction;
        }
        else {
            return innerTransactions.map(itemInss => {
                if (itemInss.supportedVersion.find(i => i === type_1.TxVersion.LEGACY) === undefined)
                    throw Error('has error type transaction');
                const t = new web3_js_1.Transaction().add(...itemInss.instructions);
                t.recentBlockhash = _recentBlockhash;
                t.feePayer = payer;
                if (itemInss.signers.length > 0)
                    t.sign(...itemInss.signers);
                return t;
            });
        }
    });
}
exports.buildTransaction = buildTransaction;
//# sourceMappingURL=util.js.map