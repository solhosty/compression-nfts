import { Connection, PublicKey, TransactionInstruction } from '@solana/web3.js';
import BN from 'bn.js';
import { AmmV3PoolInfo, ReturnTypeFetchMultiplePoolTickArrays } from '../ammV3';
import { Base, ComputeBudgetConfig, InnerTransaction, InstructionType, TokenAccount, TxVersion } from '../base';
import { ApiPoolInfo, ApiPoolInfoItem } from '../baseInfo';
import { Currency, CurrencyAmount, Percent, Price, Token, TokenAmount } from '../entity';
export type PoolType = AmmV3PoolInfo | ApiPoolInfoItem;
type RoutePathType = {
    [routeMint: string]: {
        in: PoolType[];
        out: PoolType[];
        mDecimals: number;
    };
};
interface PoolAccountInfoV4 {
    ammId: string;
    status: BN;
    baseDecimals: number;
    quoteDecimals: number;
    lpDecimals: number;
    baseReserve: BN;
    quoteReserve: BN;
    lpSupply: BN;
    startTime: BN;
}
export interface ComputeAmountOutAmmLayout {
    amountIn: CurrencyAmount | TokenAmount;
    amountOut: CurrencyAmount | TokenAmount;
    minAmountOut: CurrencyAmount | TokenAmount;
    currentPrice: Price | undefined;
    executionPrice: Price | null;
    priceImpact: Percent;
    fee: CurrencyAmount[];
    routeType: 'amm';
    poolKey: PoolType[];
    remainingAccounts: PublicKey[][];
    middleMint: PublicKey | undefined;
    poolReady: boolean;
    poolType: string | undefined;
}
export interface ComputeAmountOutRouteLayout {
    amountIn: CurrencyAmount | TokenAmount;
    amountOut: CurrencyAmount | TokenAmount;
    minAmountOut: CurrencyAmount | TokenAmount;
    currentPrice: Price | undefined;
    executionPrice: Price | null;
    priceImpact: Percent;
    fee: CurrencyAmount[];
    routeType: 'route';
    poolKey: PoolType[];
    remainingAccounts: PublicKey[][];
    middleMint: PublicKey | undefined;
    poolReady: boolean;
    poolType: (string | undefined)[];
}
type ComputeAmountOutLayout = ComputeAmountOutAmmLayout | ComputeAmountOutRouteLayout;
type makeSwapInstructionParam = {
    ownerInfo: {
        wallet: PublicKey;
        sourceToken: PublicKey;
        routeToken?: PublicKey;
        destinationToken: PublicKey;
        userPdaAccount?: PublicKey;
    };
    inputMint: PublicKey;
    routeProgram: PublicKey;
    swapInfo: ComputeAmountOutLayout;
};
export interface ReturnTypeGetAllRoute {
    directPath: PoolType[];
    addLiquidityPools: ApiPoolInfoItem[];
    routePathDict: RoutePathType;
    needSimulate: ApiPoolInfoItem[];
    needTickArray: AmmV3PoolInfo[];
}
export interface ReturnTypeFetchMultipleInfo {
    [ammId: string]: PoolAccountInfoV4;
}
export type ReturnTypeGetAddLiquidityDefaultPool = ApiPoolInfoItem | undefined;
export type ReturnTypeGetAllRouteComputeAmountOut = ComputeAmountOutLayout[];
export declare class TradeV2 extends Base {
    static getAllRoute({ inputMint, outputMint, apiPoolList, ammV3List }: {
        inputMint: PublicKey;
        outputMint: PublicKey;
        apiPoolList?: ApiPoolInfo;
        ammV3List?: AmmV3PoolInfo[];
    }): ReturnTypeGetAllRoute;
    static fetchMultipleInfo({ connection, pools, batchRequest }: {
        connection: Connection;
        pools: ApiPoolInfoItem[];
        batchRequest?: boolean;
    }): Promise<ReturnTypeFetchMultipleInfo>;
    static getAddLiquidityDefaultPool({ addLiquidityPools, poolInfosCache }: {
        addLiquidityPools: ApiPoolInfoItem[];
        poolInfosCache: {
            [ammId: string]: PoolAccountInfoV4;
        };
    }): ReturnTypeGetAddLiquidityDefaultPool;
    private static ComparePoolSize;
    static getAllRouteComputeAmountOut({ inputTokenAmount, outputToken, directPath, routePathDict, simulateCache, tickCache, slippage, chainTime }: {
        directPath: PoolType[];
        routePathDict: RoutePathType;
        simulateCache: ReturnTypeFetchMultipleInfo;
        tickCache: ReturnTypeFetchMultiplePoolTickArrays;
        inputTokenAmount: CurrencyAmount | TokenAmount;
        outputToken: Token | Currency;
        slippage: Percent;
        chainTime: number;
    }): ReturnTypeGetAllRouteComputeAmountOut;
    private static computeAmountOut;
    static makeSwapInstruction({ routeProgram, ownerInfo, inputMint, swapInfo }: makeSwapInstructionParam): {
        address: {};
        innerTransaction: {
            instructions: TransactionInstruction[];
            signers: any[];
            lookupTableAddress: any[];
            instructionTypes: InstructionType[];
            supportedVersion: TxVersion[];
        };
    };
    static makeSwapInstructionSimple({ connection, swapInfo, ownerInfo, checkTransaction, computeBudgetConfig }: {
        connection: Connection;
        swapInfo: ComputeAmountOutLayout;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            associatedOnly: boolean;
        };
        checkTransaction: boolean;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<{
        address: {};
        innerTransactions: InnerTransaction[];
    }>;
    static getAssociatedMiddleStatusAccount({ programId, fromPoolId, middleMint, owner, }: {
        programId: PublicKey;
        fromPoolId: PublicKey;
        middleMint: PublicKey;
        owner: PublicKey;
    }): PublicKey;
}
export {};
