"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TradeV2 = void 0;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
const ammV3_1 = require("../ammV3");
const constants_1 = require("../ammV3/utils/constants");
const base_1 = require("../base");
const instrument_1 = require("../base/instrument");
const common_1 = require("../common");
const entity_1 = require("../entity");
const liquidity_1 = require("../liquidity");
const instrument_2 = require("./instrument");
class TradeV2 extends base_1.Base {
    static getAllRoute({ inputMint, outputMint, apiPoolList, ammV3List }) {
        var _a, _b;
        const needSimulate = {};
        const needTickArray = {};
        const directPath = [];
        const routePathDict = {}; // {[route mint: string]: {in: [] , out: []}}
        for (const itemAmmPool of ammV3List !== null && ammV3List !== void 0 ? ammV3List : []) {
            if ((itemAmmPool.mintA.mint.equals(inputMint) && itemAmmPool.mintB.mint.equals(outputMint)) || (itemAmmPool.mintA.mint.equals(outputMint) && itemAmmPool.mintB.mint.equals(inputMint))) {
                directPath.push(itemAmmPool);
                needTickArray[itemAmmPool.id.toString()] = itemAmmPool;
            }
            if (itemAmmPool.mintA.mint.equals(inputMint)) {
                const t = itemAmmPool.mintB.mint.toString();
                if (routePathDict[t] === undefined)
                    routePathDict[t] = { in: [], out: [], mDecimals: itemAmmPool.mintB.decimals };
                routePathDict[t].in.push(itemAmmPool);
            }
            if (itemAmmPool.mintB.mint.equals(inputMint)) {
                const t = itemAmmPool.mintA.mint.toString();
                if (routePathDict[t] === undefined)
                    routePathDict[t] = { in: [], out: [], mDecimals: itemAmmPool.mintA.decimals };
                routePathDict[t].in.push(itemAmmPool);
            }
            if (itemAmmPool.mintA.mint.equals(outputMint)) {
                const t = itemAmmPool.mintB.mint.toString();
                if (routePathDict[t] === undefined)
                    routePathDict[t] = { in: [], out: [], mDecimals: itemAmmPool.mintB.decimals };
                routePathDict[t].out.push(itemAmmPool);
            }
            if (itemAmmPool.mintB.mint.equals(outputMint)) {
                const t = itemAmmPool.mintA.mint.toString();
                if (routePathDict[t] === undefined)
                    routePathDict[t] = { in: [], out: [], mDecimals: itemAmmPool.mintA.decimals };
                routePathDict[t].out.push(itemAmmPool);
            }
        }
        const addLiquidityPools = [];
        const _inputMint = inputMint.toString();
        const _outputMint = outputMint.toString();
        for (const itemAmmPool of (_a = (apiPoolList !== null && apiPoolList !== void 0 ? apiPoolList : {}).official) !== null && _a !== void 0 ? _a : []) {
            if ((itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint) || (itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint)) {
                directPath.push(itemAmmPool);
                needSimulate[itemAmmPool.id] = itemAmmPool;
                addLiquidityPools.push(itemAmmPool);
            }
            if (itemAmmPool.baseMint === _inputMint) {
                if (routePathDict[itemAmmPool.quoteMint] === undefined)
                    routePathDict[itemAmmPool.quoteMint] = { in: [], out: [], mDecimals: itemAmmPool.quoteDecimals };
                routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
            }
            if (itemAmmPool.quoteMint === _inputMint) {
                if (routePathDict[itemAmmPool.baseMint] === undefined)
                    routePathDict[itemAmmPool.baseMint] = { in: [], out: [], mDecimals: itemAmmPool.baseDecimals };
                routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
            }
            if (itemAmmPool.baseMint === _outputMint) {
                if (routePathDict[itemAmmPool.quoteMint] === undefined)
                    routePathDict[itemAmmPool.quoteMint] = { in: [], out: [], mDecimals: itemAmmPool.quoteDecimals };
                routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
            }
            if (itemAmmPool.quoteMint === _outputMint) {
                if (routePathDict[itemAmmPool.baseMint] === undefined)
                    routePathDict[itemAmmPool.baseMint] = { in: [], out: [], mDecimals: itemAmmPool.baseDecimals };
                routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
            }
        }
        const _insertAddLiquidityPool = addLiquidityPools.length === 0;
        for (const itemAmmPool of (_b = (apiPoolList !== null && apiPoolList !== void 0 ? apiPoolList : {}).unOfficial) !== null && _b !== void 0 ? _b : []) {
            if ((itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint) || (itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint)) {
                directPath.push(itemAmmPool);
                needSimulate[itemAmmPool.id] = itemAmmPool;
                if (_insertAddLiquidityPool)
                    addLiquidityPools.push(itemAmmPool);
            }
            if (itemAmmPool.baseMint === _inputMint) {
                if (routePathDict[itemAmmPool.quoteMint] === undefined)
                    routePathDict[itemAmmPool.quoteMint] = { in: [], out: [], mDecimals: itemAmmPool.quoteDecimals };
                routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
            }
            if (itemAmmPool.quoteMint === _inputMint) {
                if (routePathDict[itemAmmPool.baseMint] === undefined)
                    routePathDict[itemAmmPool.baseMint] = { in: [], out: [], mDecimals: itemAmmPool.baseDecimals };
                routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
            }
            if (itemAmmPool.baseMint === _outputMint) {
                if (routePathDict[itemAmmPool.quoteMint] === undefined)
                    routePathDict[itemAmmPool.quoteMint] = { in: [], out: [], mDecimals: itemAmmPool.quoteDecimals };
                routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
            }
            if (itemAmmPool.quoteMint === _outputMint) {
                if (routePathDict[itemAmmPool.baseMint] === undefined)
                    routePathDict[itemAmmPool.baseMint] = { in: [], out: [], mDecimals: itemAmmPool.baseDecimals };
                routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
            }
        }
        for (const t of Object.keys(routePathDict)) {
            if (routePathDict[t].in.length === 1 && routePathDict[t].out.length === 1 && String(routePathDict[t].in[0].id) === String(routePathDict[t].out[0].id)) {
                delete routePathDict[t];
                continue;
            }
            if (routePathDict[t].in.length === 0 || routePathDict[t].out.length === 0) {
                delete routePathDict[t];
                continue;
            }
            const info = routePathDict[t];
            for (const infoIn of info.in) {
                for (const infoOut of info.out) {
                    if (infoIn.version === 6 && needTickArray[infoIn.id.toString()] === undefined) {
                        needTickArray[infoIn.id.toString()] = infoIn;
                    }
                    else if (infoIn.version !== 6 && needSimulate[infoIn.id] === undefined) {
                        needSimulate[infoIn.id] = infoIn;
                    }
                    if (infoOut.version === 6 && needTickArray[infoOut.id.toString()] === undefined) {
                        needTickArray[infoOut.id.toString()] = infoOut;
                    }
                    else if (infoOut.version !== 6 && needSimulate[infoOut.id] === undefined) {
                        needSimulate[infoOut.id] = infoOut;
                    }
                }
            }
        }
        return {
            directPath,
            addLiquidityPools,
            routePathDict,
            needSimulate: Object.values(needSimulate),
            needTickArray: Object.values(needTickArray),
        };
    }
    static fetchMultipleInfo({ connection, pools, batchRequest = true }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (pools.find(i => i.version === 5))
                yield (0, liquidity_1.initStableModelLayout)(connection);
            const instructions = pools.map((pool) => liquidity_1.Liquidity.makeSimulatePoolInfoInstruction({ poolKeys: (0, common_1.jsonInfo2PoolKeys)(pool) }));
            const logs = yield (0, common_1.simulateMultipleInstruction)(connection, instructions.map(i => i.innerTransaction.instructions).flat(), "GetPoolData", batchRequest);
            const poolsInfo = {};
            for (const log of logs) {
                const json = (0, common_1.parseSimulateLogToJson)(log, "GetPoolData");
                const ammId = JSON.parse(json)['amm_id'];
                const status = new bn_js_1.default((0, common_1.parseSimulateValue)(json, "status"));
                const baseDecimals = Number((0, common_1.parseSimulateValue)(json, "coin_decimals"));
                const quoteDecimals = Number((0, common_1.parseSimulateValue)(json, "pc_decimals"));
                const lpDecimals = Number((0, common_1.parseSimulateValue)(json, "lp_decimals"));
                const baseReserve = new bn_js_1.default((0, common_1.parseSimulateValue)(json, "pool_coin_amount"));
                const quoteReserve = new bn_js_1.default((0, common_1.parseSimulateValue)(json, "pool_pc_amount"));
                const lpSupply = new bn_js_1.default((0, common_1.parseSimulateValue)(json, "pool_lp_supply"));
                // TODO fix it when split stable
                let startTime = "0";
                try {
                    startTime = (0, common_1.parseSimulateValue)(json, "pool_open_time");
                }
                catch (error) {
                    //
                }
                poolsInfo[ammId] = {
                    ammId,
                    status,
                    baseDecimals,
                    quoteDecimals,
                    lpDecimals,
                    baseReserve,
                    quoteReserve,
                    lpSupply,
                    startTime: new bn_js_1.default(startTime),
                };
            }
            return poolsInfo;
        });
    }
    static getAddLiquidityDefaultPool({ addLiquidityPools, poolInfosCache }) {
        if (addLiquidityPools.length === 0)
            return undefined;
        if (addLiquidityPools.length === 1)
            return addLiquidityPools[0];
        addLiquidityPools.sort((a, b) => b.version - a.version);
        if (addLiquidityPools[0].version !== addLiquidityPools[1].version)
            return addLiquidityPools[0];
        const _addLiquidityPools = addLiquidityPools.filter(i => i.version === addLiquidityPools[0].version);
        _addLiquidityPools.sort((a, b) => this.ComparePoolSize(a, b, poolInfosCache));
        return _addLiquidityPools[0];
    }
    static ComparePoolSize(a, b, ammIdToPoolInfo) {
        const aInfo = ammIdToPoolInfo[a.id];
        const bInfo = ammIdToPoolInfo[b.id];
        if (aInfo === undefined)
            return 1;
        if (bInfo === undefined)
            return -1;
        if (a.baseMint === b.baseMint) {
            const sub = aInfo.baseReserve.sub(bInfo.baseReserve);
            return sub.gte(entity_1.ZERO) ? -1 : 1;
        }
        else {
            const sub = aInfo.baseReserve.sub(bInfo.quoteReserve);
            return sub.gte(entity_1.ZERO) ? -1 : 1;
        }
    }
    static getAllRouteComputeAmountOut({ inputTokenAmount, outputToken, directPath, routePathDict, simulateCache, tickCache, slippage, chainTime }) {
        console.log('sdk call log', directPath.length, Object.keys(routePathDict).length, Object.keys(simulateCache).length, Object.keys(tickCache).length, inputTokenAmount.raw.toString(), inputTokenAmount instanceof entity_1.TokenAmount ? inputTokenAmount.token.mint.toString() : 'sol', outputToken instanceof entity_1.Token ? outputToken.mint.toString() : 'sol', slippage, chainTime);
        const amountIn = inputTokenAmount;
        const outRoute = [];
        for (const itemPool of directPath) {
            if (itemPool.version === 6) {
                try {
                    const { amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee, remainingAccounts } = ammV3_1.AmmV3.computeAmountOutFormat({
                        poolInfo: itemPool,
                        tickArrayCache: tickCache[itemPool.id.toString()],
                        amountIn,
                        currencyOut: outputToken,
                        slippage,
                    });
                    outRoute.push({ amountIn, amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee: [fee], remainingAccounts: [remainingAccounts], routeType: 'amm', poolKey: [itemPool], middleMint: undefined, poolReady: itemPool.startTime < chainTime, poolType: 'CLMM' });
                }
                catch (e) {
                    // 
                }
            }
            else {
                try {
                    if (![1, 6, 7].includes(simulateCache[itemPool.id].status.toNumber()))
                        continue;
                    const { amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee } = liquidity_1.Liquidity.computeAmountOut({
                        poolKeys: (0, common_1.jsonInfo2PoolKeys)(itemPool),
                        poolInfo: simulateCache[itemPool.id],
                        amountIn,
                        currencyOut: outputToken,
                        slippage,
                    });
                    outRoute.push({ amountIn, amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee: [fee], routeType: 'amm', poolKey: [itemPool], remainingAccounts: [], middleMint: undefined, poolReady: simulateCache[itemPool.id].startTime.toNumber() < chainTime, poolType: itemPool.version === 5 ? 'STABLE' : undefined });
                }
                catch (e) {
                    //
                }
            }
        }
        for (const [routeMint, info] of Object.entries(routePathDict)) {
            for (const iFromPool of info.in) {
                if (!simulateCache[iFromPool.id] && !tickCache[iFromPool.id.toString()])
                    continue;
                if (iFromPool.version !== 6 && ![1, 6, 7].includes(simulateCache[iFromPool.id].status.toNumber()))
                    continue;
                for (const iOutPool of info.out) {
                    if (!simulateCache[iOutPool.id] && !tickCache[iOutPool.id.toString()])
                        continue;
                    if (iOutPool.version !== 6 && ![1, 6, 7].includes(simulateCache[iOutPool.id].status.toNumber()))
                        continue;
                    try {
                        const { amountOut, minAmountOut, executionPrice, priceImpact, fee, remainingAccounts } = TradeV2.computeAmountOut({
                            middleMintInfo: {
                                mint: new web3_js_1.PublicKey(routeMint),
                                decimals: info.mDecimals
                            },
                            amountIn,
                            currencyOut: outputToken,
                            slippage,
                            fromPool: iFromPool,
                            toPool: iOutPool,
                            simulateCache,
                            tickCache
                        });
                        const infoAPoolOpen = iFromPool.version === 6 ? iFromPool.startTime < chainTime : simulateCache[iFromPool.id].startTime.toNumber() < chainTime;
                        const infoBPoolOpen = iOutPool.version === 6 ? iOutPool.startTime < chainTime : simulateCache[iOutPool.id].startTime.toNumber() < chainTime;
                        const poolTypeA = iFromPool.version === 6 ? 'CLMM' : iFromPool.version === 5 ? "STABLE" : undefined;
                        const poolTypeB = iOutPool.version === 6 ? 'CLMM' : iOutPool.version === 5 ? "STABLE" : undefined;
                        outRoute.push({
                            amountIn, amountOut, minAmountOut, currentPrice: undefined, executionPrice, priceImpact, fee, routeType: 'route', poolKey: [iFromPool, iOutPool], remainingAccounts, middleMint: new web3_js_1.PublicKey(routeMint), poolReady: infoAPoolOpen && infoBPoolOpen, poolType: [poolTypeA, poolTypeB]
                        });
                    }
                    catch (e) {
                        //
                    }
                }
            }
        }
        outRoute.sort((a, b) => (a.amountOut.raw.sub(b.amountOut.raw).gt(entity_1.ZERO) ? -1 : 1));
        console.log('sdk call log', outRoute.map(i => {
            var _a, _b;
            return (i.routeType === 'amm' ? { type: i.routeType, inValue: i.amountIn.toFixed(), value: i.amountOut.toFixed(), e: (_a = i.executionPrice) === null || _a === void 0 ? void 0 : _a.toFixed(5), valueMin: i.minAmountOut.toFixed(), v1: i.poolKey[0].version, p1: String(i.poolKey[0].id), priceI: i.priceImpact.denominator.eq(new bn_js_1.default(0)) ? 0 : i.priceImpact.toFixed(5) } : {
                type: i.routeType, inValue: i.amountIn.toFixed(), value: i.amountOut.toFixed(), e: (_b = i.executionPrice) === null || _b === void 0 ? void 0 : _b.toFixed(5), valueMin: i.minAmountOut.toFixed(), v1: i.poolKey[0].version, v2: i.poolKey[1].version, p1: String(i.poolKey[0].id), p2: String(i.poolKey[1].id), priceI: i.priceImpact.denominator.eq(new bn_js_1.default(0)) ? 0 : i.priceImpact.toFixed(5)
            });
        }));
        console.log('sdk call log', outRoute.length);
        return outRoute;
    }
    static computeAmountOut({ middleMintInfo, amountIn, currencyOut, slippage, fromPool, toPool, simulateCache, tickCache, }) {
        const middleToken = new entity_1.Token(middleMintInfo.mint, middleMintInfo.decimals);
        let minMiddleAmountOut;
        let firstPriceImpact;
        let firstFee;
        let firstRemainingAccounts;
        const _slippage = new entity_1.Percent(0, 100);
        if (fromPool.version === 6) {
            const { minAmountOut: _minMiddleAmountOut, priceImpact: _firstPriceImpact, fee: _firstFee, remainingAccounts: _firstRemainingAccounts } = ammV3_1.AmmV3.computeAmountOutFormat({
                poolInfo: fromPool,
                tickArrayCache: tickCache[fromPool.id.toString()],
                amountIn,
                currencyOut: middleToken,
                slippage: _slippage,
            });
            minMiddleAmountOut = _minMiddleAmountOut;
            firstPriceImpact = _firstPriceImpact;
            firstFee = _firstFee;
            firstRemainingAccounts = _firstRemainingAccounts;
        }
        else {
            const { minAmountOut: _minMiddleAmountOut, priceImpact: _firstPriceImpact, fee: _firstFee, } = liquidity_1.Liquidity.computeAmountOut({
                poolKeys: (0, common_1.jsonInfo2PoolKeys)(fromPool),
                poolInfo: simulateCache[fromPool.id],
                amountIn,
                currencyOut: middleToken,
                slippage: _slippage,
            });
            minMiddleAmountOut = _minMiddleAmountOut;
            firstPriceImpact = _firstPriceImpact;
            firstFee = _firstFee;
        }
        let amountOut;
        let minAmountOut;
        let secondPriceImpact;
        let secondFee;
        let secondRemainingAccounts;
        if (toPool.version === 6) {
            const { amountOut: _amountOut, minAmountOut: _minAmountOut, priceImpact: _secondPriceImpact, fee: _secondFee, remainingAccounts: _secondRemainingAccounts } = ammV3_1.AmmV3.computeAmountOutFormat({
                poolInfo: toPool,
                tickArrayCache: tickCache[toPool.id.toString()],
                amountIn: minMiddleAmountOut,
                currencyOut,
                slippage,
            });
            amountOut = _amountOut;
            minAmountOut = _minAmountOut;
            secondPriceImpact = _secondPriceImpact;
            secondFee = _secondFee;
            secondRemainingAccounts = _secondRemainingAccounts;
        }
        else {
            const { amountOut: _amountOut, minAmountOut: _minAmountOut, priceImpact: _secondPriceImpact, fee: _secondFee, } = liquidity_1.Liquidity.computeAmountOut({
                poolKeys: (0, common_1.jsonInfo2PoolKeys)(toPool),
                poolInfo: simulateCache[toPool.id],
                amountIn: minMiddleAmountOut,
                currencyOut,
                slippage,
            });
            amountOut = _amountOut;
            minAmountOut = _minAmountOut;
            secondPriceImpact = _secondPriceImpact;
            secondFee = _secondFee;
        }
        let executionPrice = null;
        const amountInRaw = amountIn.raw;
        const amountOutRaw = amountOut.raw;
        const currencyIn = amountIn instanceof entity_1.TokenAmount ? amountIn.token : amountIn.currency;
        if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {
            executionPrice = new entity_1.Price(currencyIn, amountInRaw, currencyOut, amountOutRaw);
        }
        return {
            // middleAmountOut,
            minMiddleAmountOut,
            amountOut,
            minAmountOut,
            executionPrice,
            priceImpact: firstPriceImpact.add(secondPriceImpact),
            fee: [firstFee, secondFee],
            remainingAccounts: [firstRemainingAccounts, secondRemainingAccounts]
        };
    }
    static makeSwapInstruction({ routeProgram, ownerInfo, inputMint, swapInfo }) {
        if (swapInfo.routeType === 'amm') {
            if (swapInfo.poolKey[0].version === 6) {
                const _poolKey = swapInfo.poolKey[0];
                const sqrtPriceLimitX64 = inputMint.equals((_poolKey).mintA.mint)
                    ? constants_1.MIN_SQRT_PRICE_X64.add(entity_1.ONE)
                    : constants_1.MAX_SQRT_PRICE_X64.sub(entity_1.ONE);
                return ammV3_1.AmmV3.makeSwapBaseInInstructions({
                    poolInfo: _poolKey,
                    ownerInfo: {
                        wallet: ownerInfo.wallet,
                        tokenAccountA: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.sourceToken : ownerInfo.destinationToken,
                        tokenAccountB: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.destinationToken : ownerInfo.sourceToken,
                    },
                    inputMint,
                    amountIn: swapInfo.amountIn.raw,
                    amountOutMin: swapInfo.minAmountOut.raw,
                    sqrtPriceLimitX64,
                    remainingAccounts: swapInfo.remainingAccounts[0]
                });
            }
            else {
                const _poolKey = swapInfo.poolKey[0];
                return liquidity_1.Liquidity.makeSwapInstruction({
                    poolKeys: (0, common_1.jsonInfo2PoolKeys)(_poolKey),
                    userKeys: {
                        tokenAccountIn: ownerInfo.sourceToken,
                        tokenAccountOut: ownerInfo.destinationToken,
                        owner: ownerInfo.wallet,
                    },
                    amountIn: swapInfo.amountIn.raw,
                    amountOut: swapInfo.minAmountOut.raw,
                    fixedSide: "in",
                });
            }
        }
        else if (swapInfo.routeType === 'route') {
            const poolKey1 = swapInfo.poolKey[0];
            const poolKey2 = swapInfo.poolKey[1];
            return {
                address: {},
                innerTransaction: {
                    instructions: [
                        (0, instrument_2.routeInstruction)(routeProgram, ownerInfo.wallet, ownerInfo.sourceToken, ownerInfo.routeToken, ownerInfo.destinationToken, inputMint.toString(), swapInfo.middleMint.toString(), poolKey1, poolKey2, swapInfo.amountIn.raw, swapInfo.minAmountOut.raw, swapInfo.remainingAccounts)
                    ],
                    signers: [],
                    lookupTableAddress: [],
                    instructionTypes: [base_1.InstructionType.routeSwap1, base_1.InstructionType.routeSwap2],
                    supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                }
            };
        }
        else {
            throw Error('route type error');
        }
    }
    static makeSwapInstructionSimple({ connection, swapInfo, ownerInfo, checkTransaction, computeBudgetConfig }) {
        return __awaiter(this, void 0, void 0, function* () {
            const frontInstructions = [];
            const endInstructions = [];
            const frontInstructionsType = [];
            const endInstructionsType = [];
            const signers = [];
            const amountIn = swapInfo.amountIn;
            const amountOut = swapInfo.amountOut;
            const useSolBalance = !(amountIn instanceof entity_1.TokenAmount);
            const outSolBalance = !(amountOut instanceof entity_1.TokenAmount);
            const inputMint = amountIn instanceof entity_1.TokenAmount ? amountIn.token.mint : entity_1.Token.WSOL.mint;
            const middleMint = swapInfo.middleMint;
            const outputMint = amountOut instanceof entity_1.TokenAmount ? amountOut.token.mint : entity_1.Token.WSOL.mint;
            const routeProgram = new web3_js_1.PublicKey('routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS');
            const sourceToken = yield this._selectOrCreateTokenAccount({
                mint: inputMint,
                tokenAccounts: useSolBalance ? [] : ownerInfo.tokenAccounts,
                createInfo: useSolBalance ? {
                    connection,
                    payer: ownerInfo.wallet,
                    amount: amountIn.raw,
                    frontInstructions,
                    endInstructions,
                    signers,
                    frontInstructionsType,
                    endInstructionsType,
                } : undefined,
                owner: ownerInfo.wallet,
                associatedOnly: useSolBalance ? false : ownerInfo.associatedOnly
            });
            if (sourceToken === undefined) {
                throw Error('input account check error');
            }
            const destinationToken = yield this._selectOrCreateTokenAccount({
                mint: outputMint,
                tokenAccounts: ownerInfo.tokenAccounts,
                createInfo: {
                    connection,
                    payer: ownerInfo.wallet,
                    amount: 0,
                    frontInstructions,
                    endInstructions: outSolBalance ? endInstructions : undefined,
                    signers,
                    frontInstructionsType,
                    endInstructionsType,
                },
                owner: ownerInfo.wallet,
                associatedOnly: ownerInfo.associatedOnly
            });
            let routeToken = undefined;
            if (swapInfo.routeType === 'route') {
                routeToken = yield this._selectOrCreateTokenAccount({
                    mint: middleMint,
                    tokenAccounts: ownerInfo.tokenAccounts,
                    createInfo: {
                        connection,
                        payer: ownerInfo.wallet,
                        amount: 0,
                        frontInstructions,
                        endInstructions,
                        signers,
                        frontInstructionsType,
                        endInstructionsType,
                    },
                    owner: ownerInfo.wallet,
                    associatedOnly: false
                });
            }
            const ins = this.makeSwapInstruction({
                routeProgram,
                inputMint,
                swapInfo,
                ownerInfo: {
                    wallet: ownerInfo.wallet,
                    sourceToken,
                    routeToken,
                    destinationToken: destinationToken,
                    userPdaAccount: swapInfo.poolKey.length === 2 ? this.getAssociatedMiddleStatusAccount({
                        programId: routeProgram, fromPoolId: new web3_js_1.PublicKey(String(swapInfo.poolKey[0].id)), owner: ownerInfo.wallet, middleMint: swapInfo.middleMint
                    }) : undefined
                }
            });
            const innerTransactions = [];
            const { instructions, instructionTypes } = computeBudgetConfig ? (0, instrument_1.addComputeBudget)(computeBudgetConfig).innerTransaction : { instructions: [], instructionTypes: [] };
            const tempIns = [...instructions, ...frontInstructions, ...ins.innerTransaction.instructions, ...endInstructions];
            const tempInsType = [...instructionTypes, ...frontInstructionsType, ...ins.innerTransaction.instructionTypes, ...endInstructionsType];
            const tempSigner = [...signers, ...ins.innerTransaction.signers];
            if (checkTransaction) {
                if ((0, common_1.forecastTransactionSize)(tempIns, [ownerInfo.wallet, ...tempSigner.map(i => i.publicKey)])) {
                    innerTransactions.push({
                        instructions: tempIns,
                        signers: tempSigner,
                        lookupTableAddress: [],
                        instructionTypes: tempInsType,
                        supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                    });
                }
                else {
                    if (frontInstructions.length > 0) {
                        innerTransactions.push({
                            instructions: frontInstructions,
                            signers,
                            lookupTableAddress: [],
                            instructionTypes: frontInstructionsType,
                            supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                        });
                    }
                    if ((0, common_1.forecastTransactionSize)([...instructions, ...ins.innerTransaction.instructions], [ownerInfo.wallet])) {
                        innerTransactions.push({
                            instructions: [...instructions, ...ins.innerTransaction.instructions],
                            signers: ins.innerTransaction.signers,
                            lookupTableAddress: ins.innerTransaction.lookupTableAddress,
                            instructionTypes: [...instructionTypes, ...ins.innerTransaction.instructionTypes],
                            supportedVersion: ins.innerTransaction.supportedVersion
                        });
                    }
                    else if ((0, common_1.forecastTransactionSize)(ins.innerTransaction.instructions, [ownerInfo.wallet])) {
                        innerTransactions.push({
                            instructions: ins.innerTransaction.instructions,
                            signers: ins.innerTransaction.signers,
                            lookupTableAddress: ins.innerTransaction.lookupTableAddress,
                            instructionTypes: ins.innerTransaction.instructionTypes,
                            supportedVersion: ins.innerTransaction.supportedVersion
                        });
                    }
                    else {
                        for (let index = 0; index < ins.innerTransaction.instructions.length; index++) {
                            innerTransactions.push({
                                instructions: [...instructions, ins.innerTransaction.instructions[index]],
                                signers: ins.innerTransaction.signers,
                                lookupTableAddress: [],
                                instructionTypes: [...instructionTypes, ins.innerTransaction.instructionTypes[index]],
                                supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                            });
                        }
                    }
                    if (endInstructions.length > 0) {
                        innerTransactions.push({
                            instructions: endInstructions,
                            signers: [],
                            lookupTableAddress: [],
                            instructionTypes: endInstructionsType,
                            supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                        });
                    }
                    // if (frontInstructions.length > 0) {
                    //   innerTransactions.push({
                    //     instructions: [...instructions, ...frontInstructions],
                    //     signers,
                    //     lookupTableAddress: [],
                    //     instructionTypes: [...instructionTypes, ...frontInstructionsType],
                    //     supportedVersion: [TxVersion.LEGACY, TxVersion.V0]
                    //   })
                    // }
                    // if (forecastTransactionSize(ins.innerTransaction.instructions, [ownerInfo.wallet])) {
                    //   innerTransactions.push({
                    //     instructions: [...instructions, ...ins.innerTransaction.instructions],
                    //     signers: ins.innerTransaction.signers,
                    //     lookupTableAddress: ins.innerTransaction.lookupTableAddress,
                    //     instructionTypes: [...instructionTypes, ...ins.innerTransaction.instructionTypes],
                    //     supportedVersion: ins.innerTransaction.supportedVersion
                    //   })
                    // } else {
                    //   for (let index = 0 ; index < ins.innerTransaction.instructions.length; index++) {
                    //     innerTransactions.push({
                    //       instructions: [...instructions, ins.innerTransaction.instructions[index]],
                    //       signers: ins.innerTransaction.signers,
                    //       lookupTableAddress: [],
                    //       instructionTypes: [...instructionTypes, ins.innerTransaction.instructionTypes[index]],
                    //       supportedVersion: [TxVersion.LEGACY, TxVersion.V0]
                    //     })
                    //   }
                    // }
                    // if (endInstructions.length > 0) {
                    //   innerTransactions.push({
                    //     instructions: [...instructions, ...endInstructions],
                    //     signers: [],
                    //     lookupTableAddress: [],
                    //     instructionTypes: [...instructionTypes, ...endInstructionsType],
                    //     supportedVersion: [TxVersion.LEGACY, TxVersion.V0]
                    //   })
                    // }
                }
            }
            else {
                if (swapInfo.routeType === 'amm') {
                    innerTransactions.push({
                        instructions: tempIns,
                        signers: tempSigner,
                        lookupTableAddress: [],
                        instructionTypes: tempInsType,
                        supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                    });
                }
                else {
                    if (frontInstructions.length > 0) {
                        innerTransactions.push({
                            instructions: [...instructions, ...frontInstructions],
                            signers,
                            lookupTableAddress: [],
                            instructionTypes: [...instructionTypes, ...frontInstructionsType],
                            supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                        });
                    }
                    innerTransactions.push({
                        instructions: [...instructions, ...ins.innerTransaction.instructions],
                        signers: ins.innerTransaction.signers,
                        lookupTableAddress: ins.innerTransaction.lookupTableAddress,
                        instructionTypes: [...instructionTypes, ...ins.innerTransaction.instructionTypes],
                        supportedVersion: ins.innerTransaction.supportedVersion
                    });
                    if (endInstructions.length > 0) {
                        innerTransactions.push({
                            instructions: [...instructions, ...endInstructions],
                            signers: [],
                            lookupTableAddress: [],
                            instructionTypes: [...instructionTypes, ...endInstructionsType],
                            supportedVersion: [base_1.TxVersion.LEGACY, base_1.TxVersion.V0]
                        });
                    }
                }
            }
            return {
                address: ins.address,
                innerTransactions
            };
        });
    }
    static getAssociatedMiddleStatusAccount({ programId, fromPoolId, middleMint, owner, }) {
        const { publicKey } = (0, common_1.findProgramAddress)([fromPoolId.toBuffer(), middleMint.toBuffer(), owner.toBuffer()], programId);
        return publicKey;
    }
}
exports.TradeV2 = TradeV2;
//# sourceMappingURL=trade.js.map