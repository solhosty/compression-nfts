"use strict";
// import BN from 'bn.js';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMultipleLookupTableInfo = exports.splitTxAndSigners = exports.simulateTransaction = exports.parseSimulateValue = exports.parseSimulateLogToJson = exports.simulateMultipleInstruction = exports.forecastTransactionSize = exports.getMultipleAccountsInfoWithCustomFlags = exports.getMultipleAccountsInfo = void 0;
// import { Spl, SPL_ACCOUNT_LAYOUT } from '../spl';
// import { TOKEN_PROGRAM_ID } from './id';
const web3_js_1 = require("@solana/web3.js");
const lodash_1 = require("./lodash");
const logger_1 = require("./logger");
const logger = logger_1.Logger.from("common/web3");
// export async function batchGetMultipleAccountsInfo() {}
function getMultipleAccountsInfo(connection, publicKeys, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { batchRequest, commitment } = Object.assign({
            batchRequest: false,
        }, config);
        const chunkedKeys = (0, lodash_1.chunkArray)(publicKeys, 100);
        let results = new Array(chunkedKeys.length).fill([]);
        if (batchRequest) {
            const batch = chunkedKeys.map((keys) => {
                const args = connection._buildArgs([keys.map((key) => key.toBase58())], commitment, "base64");
                return {
                    methodName: "getMultipleAccounts",
                    args,
                };
            });
            const _batch = (0, lodash_1.chunkArray)(batch, 10);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const unsafeResponse = yield (yield Promise.all(_batch.map((i) => __awaiter(this, void 0, void 0, function* () { return yield connection._rpcBatchRequest(i); })))).flat();
            results = unsafeResponse.map((unsafeRes) => {
                if (unsafeRes.error) {
                    return logger.throwError("failed to get info for multiple accounts", logger_1.Logger.errors.RPC_ERROR, {
                        message: unsafeRes.error.message,
                    });
                }
                return unsafeRes.result.value.map((accountInfo) => {
                    if (accountInfo) {
                        const { data, executable, lamports, owner, rentEpoch } = accountInfo;
                        if (data.length !== 2 && data[1] !== "base64") {
                            return logger.throwError("info must be base64 encoded", logger_1.Logger.errors.RPC_ERROR);
                        }
                        return {
                            data: Buffer.from(data[0], "base64"),
                            executable,
                            lamports,
                            owner: new web3_js_1.PublicKey(owner),
                            rentEpoch,
                        };
                    }
                    else {
                        return null;
                    }
                });
            });
        }
        else {
            try {
                results = (yield Promise.all(chunkedKeys.map((keys) => connection.getMultipleAccountsInfo(keys, commitment))));
            }
            catch (error) {
                if (error instanceof Error) {
                    return logger.throwError("failed to get info for multiple accounts", logger_1.Logger.errors.RPC_ERROR, {
                        message: error.message,
                    });
                }
            }
        }
        return results.flat();
    });
}
exports.getMultipleAccountsInfo = getMultipleAccountsInfo;
function getMultipleAccountsInfoWithCustomFlags(connection, publicKeysWithCustomFlag, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const multipleAccountsInfo = yield getMultipleAccountsInfo(connection, publicKeysWithCustomFlag.map((o) => o.pubkey), config);
        return publicKeysWithCustomFlag.map((o, idx) => (Object.assign(Object.assign({}, o), { accountInfo: multipleAccountsInfo[idx] })));
    });
}
exports.getMultipleAccountsInfoWithCustomFlags = getMultipleAccountsInfoWithCustomFlags;
// export async function getTokenAccountsByOwner(
//   connection: Connection,
//   owner: PublicKey,
//   config?: GetTokenAccountsByOwnerConfig
// ) {
//   const defaultConfig = {};
//   const customConfig = { ...defaultConfig, ...config };
//   const solReq = connection.getAccountInfo(owner, customConfig.commitment);
//   const tokenReq = connection.getTokenAccountsByOwner(
//     owner,
//     {
//       programId: TOKEN_PROGRAM_ID
//     },
//     customConfig.commitment
//   );
//   const [solResp, tokenResp] = await Promise.all([solReq, tokenReq]);
//   const accounts: {
//     publicKey?: PublicKey;
//     mint?: PublicKey;
//     isAssociated?: boolean;
//     amount: BN;
//     isNative: boolean;
//   }[] = [];
//   for (const { pubkey, account } of tokenResp.value) {
//     // double check layout length
//     if (account.data.length !== SPL_ACCOUNT_LAYOUT.span) {
//       return logger.throwArgumentError('invalid token account layout length', 'publicKey', pubkey);
//     }
//     const { mint, amount } = SPL_ACCOUNT_LAYOUT.decode(account.data);
//     const associatedTokenAddress = await Spl.getAssociatedTokenAddress({ mint, owner });
//     accounts.push({
//       publicKey: pubkey,
//       mint,
//       isAssociated: associatedTokenAddress.equals(pubkey),
//       amount,
//       isNative: false
//     });
//   }
//   if (solResp) {
//     accounts.push({
//       amount: new BN(solResp.lamports),
//       isNative: true
//     });
//   }
//   return accounts;
// }
/**
 * Forecast transaction size
 */
function forecastTransactionSize(instructions, signers) {
    if (instructions.length < 1) {
        return logger.throwArgumentError("no instructions provided", "instructions", instructions);
    }
    if (signers.length < 1) {
        return logger.throwArgumentError("no signers provided", "signers", signers);
    }
    const transaction = new web3_js_1.Transaction({
        recentBlockhash: "11111111111111111111111111111111",
        feePayer: signers[0],
    });
    transaction.add(...instructions);
    try {
        transaction.serialize({ verifySignatures: false });
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.forecastTransactionSize = forecastTransactionSize;
/**
 * Simulates multiple instruction
 */
function simulateMultipleInstruction(connection, instructions, keyword, batchRequest = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const feePayer = new web3_js_1.PublicKey("RaydiumSimuLateTransaction11111111111111111");
        const transactions = [];
        let transaction = new web3_js_1.Transaction();
        transaction.feePayer = feePayer;
        for (const instruction of instructions) {
            if (!forecastTransactionSize([...transaction.instructions, instruction], [feePayer])) {
                transactions.push(transaction);
                transaction = new web3_js_1.Transaction();
                transaction.feePayer = feePayer;
            }
            transaction.add(instruction);
        }
        if (transaction.instructions.length > 0) {
            transactions.push(transaction);
        }
        let results = [];
        try {
            results = yield simulateTransaction(connection, transactions, batchRequest);
            if (results.find(i => i.err !== null))
                throw Error('rpc simulateTransaction error');
        }
        catch (error) {
            if (error instanceof Error) {
                return logger.throwError("failed to simulate for instructions", logger_1.Logger.errors.RPC_ERROR, {
                    message: error.message,
                });
            }
        }
        const logs = [];
        for (const result of results) {
            logger.debug("simulate result:", result);
            if (result.logs) {
                const filteredLog = result.logs.filter((log) => log && log.includes(keyword));
                logger.debug("filteredLog:", logs);
                logger.assertArgument(filteredLog.length !== 0, "simulate log not match keyword", "keyword", keyword);
                logs.push(...filteredLog);
            }
        }
        return logs;
    });
}
exports.simulateMultipleInstruction = simulateMultipleInstruction;
function parseSimulateLogToJson(log, keyword) {
    const results = log.match(/{["\w:,]+}/g);
    if (!results || results.length !== 1) {
        return logger.throwArgumentError("simulate log fail to match json", "keyword", keyword);
    }
    return results[0];
}
exports.parseSimulateLogToJson = parseSimulateLogToJson;
function parseSimulateValue(log, key) {
    const reg = new RegExp(`"${key}":(\\d+)`, "g");
    const results = reg.exec(log);
    if (!results || results.length !== 2) {
        return logger.throwArgumentError("simulate log fail to match key", "key", key);
    }
    return results[1];
}
exports.parseSimulateValue = parseSimulateValue;
function simulateTransaction(connection, transactions, batchRequest) {
    return __awaiter(this, void 0, void 0, function* () {
        let results = [];
        if (batchRequest) {
            const getLatestBlockhash = yield connection.getLatestBlockhash();
            const encodedTransactions = [];
            for (const transaction of transactions) {
                transaction.recentBlockhash = getLatestBlockhash.blockhash;
                transaction.lastValidBlockHeight = getLatestBlockhash.lastValidBlockHeight;
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                const message = transaction._compile();
                const signData = message.serialize();
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                const wireTransaction = transaction._serialize(signData);
                const encodedTransaction = wireTransaction.toString('base64');
                encodedTransactions.push(encodedTransaction);
            }
            const batch = encodedTransactions.map((keys) => {
                const args = connection._buildArgs([keys], undefined, "base64");
                return {
                    methodName: "simulateTransaction",
                    args,
                };
            });
            const reqData = [];
            const itemReqIndex = 20;
            for (let i = 0; i < Math.ceil(batch.length / itemReqIndex); i++) {
                reqData.push(batch.slice(i * itemReqIndex, (i + 1) * itemReqIndex));
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            results = yield (yield Promise.all(reqData.map((i) => __awaiter(this, void 0, void 0, function* () { return (yield connection._rpcBatchRequest(i)).map(ii => ii.result.value); })))).flat();
        }
        else {
            try {
                results = (yield Promise.all(transactions.map((transaction) => __awaiter(this, void 0, void 0, function* () { return yield (yield connection.simulateTransaction(transaction)).value; }))));
            }
            catch (error) {
                if (error instanceof Error) {
                    return logger.throwError("failed to get info for multiple accounts", logger_1.Logger.errors.RPC_ERROR, {
                        message: error.message,
                    });
                }
            }
        }
        return results;
    });
}
exports.simulateTransaction = simulateTransaction;
function splitTxAndSigners({ instructions, signers, payer }) {
    const signerKey = {};
    for (const item of signers)
        signerKey[item.publicKey.toString()] = item;
    const transactions = [];
    let itemIns = [];
    for (const item of instructions) {
        const _itemIns = [...itemIns, item];
        const _signerStrs = new Set(_itemIns.map(i => i.keys.filter(ii => ii.isSigner).map(ii => ii.pubkey.toString())).flat());
        const _signer = [..._signerStrs.values()].map(i => new web3_js_1.PublicKey(i));
        if (forecastTransactionSize(_itemIns, [payer, ..._signer])) {
            itemIns.push(item);
        }
        else {
            transactions.push({
                instruction: itemIns,
                signer: [..._signerStrs.values()].map(i => signerKey[i]).filter(i => i !== undefined)
            });
            itemIns = [item];
        }
    }
    if (itemIns.length > 0) {
        const _signerStrs = new Set(itemIns.map(i => i.keys.filter(ii => ii.isSigner).map(ii => ii.pubkey.toString())).flat());
        transactions.push({
            instruction: itemIns,
            signer: [..._signerStrs.values()].map(i => signerKey[i]).filter(i => i !== undefined)
        });
    }
    return transactions;
}
exports.splitTxAndSigners = splitTxAndSigners;
function getMultipleLookupTableInfo({ connection, address }) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataInfos = yield getMultipleAccountsInfo(connection, address);
        const outList = [];
        for (let i = 0; i < address.length; i++) {
            const info = dataInfos[i];
            const key = address[i];
            if (!info)
                continue;
            outList.push(new web3_js_1.AddressLookupTableAccount({
                key,
                state: web3_js_1.AddressLookupTableAccount.deserialize(info.data)
            }));
        }
        return outList;
    });
}
exports.getMultipleLookupTableInfo = getMultipleLookupTableInfo;
//# sourceMappingURL=web3.js.map