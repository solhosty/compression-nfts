"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeApplicationDataEvent = exports.deserializeChangeLogEventV1 = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const AccountCompressionEvent_1 = require("../generated/types/AccountCompressionEvent");
/**
 * Helper method for indexing a {@link ConcurrentMerkleTree}
 * @param data
 * @returns
 */
function deserializeChangeLogEventV1(data) {
    const event = AccountCompressionEvent_1.accountCompressionEventBeet
        .toFixedFromData(data, 0)
        .read(data, 0);
    if (event.__kind == 'ChangeLog' && event.fields[0].__kind == 'V1') {
        const changeLogV1 = event.fields[0].fields[0];
        return {
            treeId: changeLogV1.id,
            seq: new bn_js_1.default.BN(changeLogV1.seq),
            path: changeLogV1.path,
            index: changeLogV1.index,
        };
    }
    else {
        throw Error('Unable to decode buffer as ChangeLogEvent V1');
    }
}
exports.deserializeChangeLogEventV1 = deserializeChangeLogEventV1;
/**
 * Helper function for indexing data logged via `wrap_application_data_v1`
 * @param data
 * @returns
 */
function deserializeApplicationDataEvent(data) {
    const event = AccountCompressionEvent_1.accountCompressionEventBeet
        .toFixedFromData(data, 0)
        .read(data, 0);
    switch (event.__kind) {
        case 'ApplicationData': {
            return event.fields[0];
        }
        default:
            throw Error('Unable to decode buffer as ApplicationDataEvent');
    }
}
exports.deserializeApplicationDataEvent = deserializeApplicationDataEvent;
//# sourceMappingURL=index.js.map