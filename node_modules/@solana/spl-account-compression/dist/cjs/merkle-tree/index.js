"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.emptyNode = exports.hash = exports.MerkleTree = exports.LEAF_BUFFER_LENGTH = void 0;
const js_sha3_1 = __importDefault(require("js-sha3"));
const Collections = __importStar(require("typescript-collections"));
const web3_js_1 = require("@solana/web3.js");
const { keccak_256 } = js_sha3_1.default;
let CACHE_EMPTY_NODE = new Map();
exports.LEAF_BUFFER_LENGTH = 32;
class MerkleTree {
    /**
     * Please use `MerkleTree.sparseMerkleTreeFromLeaves` to
     * create trees instead. This method is exposed for testing purposes,
     * and for those that are familiar with the MerkleTree data structure.
     * @param leaves leaf nodes of the tree
     */
    constructor(leaves) {
        let [nodes, finalLeaves] = buildLeaves(leaves);
        let seqNum = leaves.length;
        while (nodes.size() > 1) {
            let left = nodes.dequeue();
            const level = left.level;
            let right;
            if (level != nodes.peek().level) {
                right = emptyTreeNode(level, seqNum);
                seqNum++;
            }
            else {
                right = nodes.dequeue();
            }
            let parent = {
                node: hash(left.node, right.node),
                left: left,
                right: right,
                parent: undefined,
                level: level + 1,
                id: seqNum,
            };
            left.parent = parent;
            right.parent = parent;
            nodes.enqueue(parent);
            seqNum++;
        }
        this.leaves = finalLeaves;
        this.root = nodes.peek().node;
        this.depth = nodes.peek().level + 1;
    }
    /**
     * This is the recommended way to create MerkleTrees.
     * If you're trying to match an on-chain MerkleTree,
     * set `depth` to `{@link ConcurrentMerkleTreeAccount}.getMaxDepth()`
     *
     * @param leaves leaves of the tree
     * @param depth number of levels in the tree
     * @returns MerkleTree
     */
    static sparseMerkleTreeFromLeaves(leaves, depth) {
        const _leaves = [];
        for (let i = 0; i < 2 ** depth; i++) {
            if (i < leaves.length) {
                _leaves.push(leaves[i]);
            }
            else {
                _leaves.push(Buffer.alloc(32));
            }
        }
        return new MerkleTree(_leaves);
    }
    getRoot() {
        return this.root;
    }
    getProof(leafIndex, minimizeProofHeight = false, treeHeight = -1, verbose = false) {
        let proof = [];
        let node = this.leaves[leafIndex];
        let height = 0;
        while (typeof node.parent !== 'undefined') {
            if (minimizeProofHeight && height >= treeHeight) {
                break;
            }
            if (verbose) {
                console.log(`${node.level}: ${Uint8Array.from(node.node)}`);
            }
            let parent = node.parent;
            if (parent.left.id === node.id) {
                proof.push(parent.right);
                const hashed = hash(node.node, parent.right.node);
                if (!hashed.equals(parent.node)) {
                    console.log(hashed);
                    console.log(parent.node);
                    throw new Error('Invariant broken when hashing left node');
                }
            }
            else {
                proof.push(parent.left);
                const hashed = hash(parent.left.node, node.node);
                if (!hashed.equals(parent.node)) {
                    console.log(hashed);
                    console.log(parent.node);
                    throw new Error('Invariant broken when hashing right node');
                }
            }
            node = parent;
            height++;
        }
        return {
            leafIndex,
            leaf: this.leaves[leafIndex].node,
            root: this.getRoot(),
            proof: proof.map((treeNode) => treeNode.node),
        };
    }
    updateLeaf(leafIndex, newLeaf, verbose = false) {
        let leaf = this.leaves[leafIndex];
        leaf.node = newLeaf;
        let node = leaf;
        var i = 0;
        while (typeof node.parent !== 'undefined') {
            if (verbose) {
                console.log(`${i}: ${Uint8Array.from(node.node)}`);
            }
            node = node.parent;
            node.node = hash(node.left.node, node.right.node);
            i++;
        }
        if (verbose) {
            console.log(`${i}: ${Uint8Array.from(node.node)}`);
        }
        this.root = node.node;
    }
    static hashProof(merkleTreeProof, verbose = false) {
        const { leaf, leafIndex, proof } = merkleTreeProof;
        let node = new web3_js_1.PublicKey(leaf).toBuffer();
        for (let i = 0; i < proof.length; i++) {
            if ((leafIndex >> i) % 2 === 0) {
                node = hash(node, new web3_js_1.PublicKey(proof[i]).toBuffer());
            }
            else {
                node = hash(new web3_js_1.PublicKey(proof[i]).toBuffer(), node);
            }
            if (verbose)
                console.log(`node ${i} ${new web3_js_1.PublicKey(node).toString()}`);
        }
        return node;
    }
    /**
     * Verifies that a root matches the proof.
     * @param root Root of a MerkleTree
     * @param merkleTreeProof Proof to a leaf in the MerkleTree
     * @param verbose Whether to print hashed nodes
     * @returns Whether the proof is valid
     */
    static verify(root, merkleTreeProof, verbose = false) {
        const node = MerkleTree.hashProof(merkleTreeProof, verbose);
        const rehashed = new web3_js_1.PublicKey(node).toString();
        const received = new web3_js_1.PublicKey(root).toString();
        if (rehashed !== received) {
            if (verbose)
                console.log(`Roots don't match! Expected ${rehashed} got ${received}`);
            return false;
        }
        if (verbose)
            console.log(`Hashed ${rehashed} got ${received}`);
        return rehashed === received;
    }
}
exports.MerkleTree = MerkleTree;
/**
 * Uses on-chain hash fn to hash together buffers
 */
function hash(left, right) {
    return Buffer.from(keccak_256.digest(Buffer.concat([left, right])));
}
exports.hash = hash;
/*
 Breadth-first iteration over a merkle tree
*/
// export function bfs<T>(tree: Tree, iterFunc: (node: TreeNode, nodeIdx: number) => T): T[] {
//   let toExplore = [getRoot(tree)];
//   const results: T[] = []
//   let idx = 0;
//   while (toExplore.length) {
//     const nextLevel: TreeNode[] = [];
//     for (let i = 0; i < toExplore.length; i++) {
//       const node = toExplore[i];
//       if (node.left) {
//         nextLevel.push(node.left);
//       }
//       if (node.right) {
//         nextLevel.push(node.right);
//       }
//       results.push(iterFunc(node, idx));
//       idx++;
//     }
//     toExplore = nextLevel;
//   }
//   return results;
// }
/**
 * Creates the leaf node in a tree of empty leaves of height `level`.
 * Uses {@link CACHE_EMPTY_NODE} to efficiently produce
 * @param level
 * @returns
 */
function emptyNode(level) {
    if (CACHE_EMPTY_NODE.has(level)) {
        return CACHE_EMPTY_NODE.get(level);
    }
    if (level == 0) {
        return Buffer.alloc(32);
    }
    let result = hash(emptyNode(level - 1), emptyNode(level - 1));
    CACHE_EMPTY_NODE.set(level, result);
    return result;
}
exports.emptyNode = emptyNode;
/**
 * Helper function when creating a MerkleTree
 * @param level
 * @param id
 * @returns
 */
function emptyTreeNode(level, id) {
    return {
        node: emptyNode(level),
        left: undefined,
        right: undefined,
        parent: undefined,
        level: level,
        id,
    };
}
/**
 * Helper function to build a MerkleTree
 * @param leaves
 * @returns
 */
function buildLeaves(leaves) {
    let nodes = new Collections.Queue();
    let finalLeaves = [];
    leaves.forEach((buffer, index) => {
        if (buffer.length != exports.LEAF_BUFFER_LENGTH) {
            throw Error(`Provided leaf has length: ${buffer.length}, but we need all leaves to be length ${exports.LEAF_BUFFER_LENGTH}`);
        }
        const treeNode = {
            node: buffer,
            left: undefined,
            right: undefined,
            parent: undefined,
            level: 0,
            id: index,
        };
        nodes.enqueue(treeNode);
        finalLeaves.push(treeNode);
    });
    return [nodes, finalLeaves];
}
//# sourceMappingURL=index.js.map