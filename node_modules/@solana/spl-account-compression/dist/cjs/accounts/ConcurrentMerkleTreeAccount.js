"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConcurrentMerkleTreeAccountSize = exports.getCanopyDepth = exports.ConcurrentMerkleTreeAccount = void 0;
const bn_js_1 = require("bn.js");
const ConcurrentMerkleTreeHeader_1 = require("../generated/types/ConcurrentMerkleTreeHeader");
const types_1 = require("../types");
const generated_1 = require("../generated");
/**
 * This class provides all the getter methods to deserialize
 * information associated with an on-chain ConcurrentMerkleTree
 */
class ConcurrentMerkleTreeAccount {
    constructor(header, tree, canopy) {
        this.header = header;
        this.tree = tree;
        this.canopy = canopy;
    }
    static fromBuffer(buffer) {
        return deserializeConcurrentMerkleTree(buffer);
    }
    static fromAccountAddress(connection, publicKey, commitmentOrConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield connection.getAccountInfo(publicKey, commitmentOrConfig);
            if (!account) {
                throw new Error('CMT account data unexpectedly null!');
            }
            return deserializeConcurrentMerkleTree(account.data);
        });
    }
    getHeaderV1() {
        return this.header.header.fields[0];
    }
    /**
     * Returns the `maxBufferSize` for this tree, by reading the account's header
     * @returns
     */
    getMaxBufferSize() {
        return this.getHeaderV1().maxBufferSize;
    }
    /**
     * Returns the `maxDepth` of this tree, by reading the account's header
     * @returns
     */
    getMaxDepth() {
        return this.getHeaderV1().maxDepth;
    }
    /**
     * Returns `min(seq, maxBufferSize)`
     * @returns
     */
    getBufferSize() {
        return new bn_js_1.BN.BN(this.tree.bufferSize).toNumber();
    }
    /**
     * Returns the current root hash for this on-chain tree
     * @returns
     */
    getCurrentRoot() {
        return this.tree.changeLogs[this.getCurrentBufferIndex()].root.toBuffer();
    }
    /**
     * Returns the index to the spot in the on-chain buffer that stores the current
     * root and last changelog.
     *
     * Should always be `this.getCurrentSeq() % this.getMaxBufferSize()`
     * @returns
     */
    getCurrentBufferIndex() {
        return new bn_js_1.BN.BN(this.tree.activeIndex).toNumber();
    }
    /**
     * Returns the PublicKey that can execute modifying operations
     * on this tree
     * @returns
     */
    getAuthority() {
        return this.getHeaderV1().authority;
    }
    /**
     * Returns the slot that this tree was created in. Useful for indexing
     * transactions associated with this tree.
     * @returns
     */
    getCreationSlot() {
        return new bn_js_1.BN(this.getHeaderV1().creationSlot);
    }
    /**
     * Returns the number of modifying operations that have been performed
     * on this tree.
     * @returns
     */
    getCurrentSeq() {
        return new bn_js_1.BN(this.tree.sequenceNumber);
    }
    /**
     * Returns the depth of the on-chain tree-cache. Increasing the canopy depth reduces the size of the proofs
     * that have to be passed for tree instructions.
     * @returns the size
     */
    getCanopyDepth() {
        return getCanopyDepth(this.canopy.canopyBytes.length);
    }
}
exports.ConcurrentMerkleTreeAccount = ConcurrentMerkleTreeAccount;
/**
 * Return expected depth of the cached {@link Canopy} tree just from the number
 * of bytes used to store the Canopy
 *
 * @param canopyByteLength
 * @returns
 */
function getCanopyDepth(canopyByteLength) {
    if (canopyByteLength === 0) {
        return 0;
    }
    return Math.log2(canopyByteLength / 32 + 2) - 1;
}
exports.getCanopyDepth = getCanopyDepth;
function deserializeConcurrentMerkleTree(buffer) {
    let offset = 0;
    const [versionedHeader, offsetIncr] = ConcurrentMerkleTreeHeader_1.concurrentMerkleTreeHeaderBeet.deserialize(buffer);
    offset = offsetIncr;
    // Only 1 version available
    if (versionedHeader.header.__kind !== 'V1') {
        throw Error(`Header has unsupported version: ${versionedHeader.header.__kind}`);
    }
    const header = versionedHeader.header.fields[0];
    const [tree, offsetIncr2] = (0, types_1.concurrentMerkleTreeBeetFactory)(header.maxDepth, header.maxBufferSize).deserialize(buffer, offset);
    offset = offsetIncr2;
    const canopyDepth = getCanopyDepth(buffer.byteLength - offset);
    let canopy = {
        canopyBytes: [],
    };
    if (canopyDepth !== 0) {
        const [deserializedCanopy, offsetIncr3] = (0, types_1.canopyBeetFactory)(canopyDepth).deserialize(buffer, offset);
        canopy = deserializedCanopy;
        offset = offsetIncr3;
    }
    if (buffer.byteLength !== offset) {
        throw new Error('Failed to process whole buffer when deserializing Merkle Account Data');
    }
    return new ConcurrentMerkleTreeAccount(versionedHeader, tree, canopy);
}
/**
 * Calculate the expected size of an ConcurrentMerkleTreeAccount
 * @param maxDepth
 * @param maxBufferSize
 * @param canopyDepth
 * @param headerVersion
 * @returns
 */
function getConcurrentMerkleTreeAccountSize(maxDepth, maxBufferSize, canopyDepth, headerVersion = 'V1') {
    if (headerVersion != 'V1') {
        throw Error('Unsupported header version');
    }
    // The additional 2 bytes are needed for
    // - the account disciminant  (1 byte)
    // - the header version       (1 byte)
    return (2 +
        generated_1.concurrentMerkleTreeHeaderDataV1Beet.byteSize +
        (0, types_1.concurrentMerkleTreeBeetFactory)(maxDepth, maxBufferSize).byteSize +
        (canopyDepth ? (0, types_1.canopyBeetFactory)(canopyDepth).byteSize : 0));
}
exports.getConcurrentMerkleTreeAccountSize = getConcurrentMerkleTreeAccountSize;
//# sourceMappingURL=ConcurrentMerkleTreeAccount.js.map