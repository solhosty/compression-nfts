/// <reference types="node" />
export declare const LEAF_BUFFER_LENGTH: number;
export declare type MerkleTreeProof = {
    leafIndex: number;
    leaf: Buffer;
    proof: Buffer[];
    root: Buffer;
};
export declare class MerkleTree {
    leaves: TreeNode[];
    root: Buffer;
    depth: number;
    /**
     * Please use `MerkleTree.sparseMerkleTreeFromLeaves` to
     * create trees instead. This method is exposed for testing purposes,
     * and for those that are familiar with the MerkleTree data structure.
     * @param leaves leaf nodes of the tree
     */
    constructor(leaves: Buffer[]);
    /**
     * This is the recommended way to create MerkleTrees.
     * If you're trying to match an on-chain MerkleTree,
     * set `depth` to `{@link ConcurrentMerkleTreeAccount}.getMaxDepth()`
     *
     * @param leaves leaves of the tree
     * @param depth number of levels in the tree
     * @returns MerkleTree
     */
    static sparseMerkleTreeFromLeaves(leaves: Buffer[], depth: number): MerkleTree;
    getRoot(): Buffer;
    getProof(leafIndex: number, minimizeProofHeight?: boolean, treeHeight?: number, verbose?: boolean): MerkleTreeProof;
    updateLeaf(leafIndex: number, newLeaf: Buffer, verbose?: boolean): void;
    static hashProof(merkleTreeProof: MerkleTreeProof, verbose?: boolean): Buffer;
    /**
     * Verifies that a root matches the proof.
     * @param root Root of a MerkleTree
     * @param merkleTreeProof Proof to a leaf in the MerkleTree
     * @param verbose Whether to print hashed nodes
     * @returns Whether the proof is valid
     */
    static verify(root: Buffer, merkleTreeProof: MerkleTreeProof, verbose?: boolean): boolean;
}
export declare type TreeNode = {
    node: Buffer;
    left: TreeNode | undefined;
    right: TreeNode | undefined;
    parent: TreeNode | undefined;
    level: number;
    id: number;
};
/**
 * Uses on-chain hash fn to hash together buffers
 */
export declare function hash(left: Buffer, right: Buffer): Buffer;
/**
 * Creates the leaf node in a tree of empty leaves of height `level`.
 * Uses {@link CACHE_EMPTY_NODE} to efficiently produce
 * @param level
 * @returns
 */
export declare function emptyNode(level: number): Buffer;
//# sourceMappingURL=index.d.ts.map