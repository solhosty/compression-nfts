/// <reference types="node" />
import { Connection, PublicKey, TransactionInstruction } from '@solana/web3.js';
import { ValidDepthSizePair } from '../constants';
import { MerkleTreeProof } from '../merkle-tree';
/**
 * Helper function that adds proof nodes to a TransactionInstruction
 * by adding extra keys to the transaction
 */
export declare function addProof(instruction: TransactionInstruction, nodeProof: Buffer[]): TransactionInstruction;
/**
 * Helper function for {@link createInitEmptyMerkleTreeInstruction}
 *
 * @param merkleTree
 * @param authority
 * @param depthSizePair
 * @returns
 */
export declare function createInitEmptyMerkleTreeIx(merkleTree: PublicKey, authority: PublicKey, depthSizePair: ValidDepthSizePair): TransactionInstruction;
/**
 * Helper function for {@link createReplaceLeafInstruction}
 * @param merkleTree
 * @param authority
 * @param proof
 * @param newLeaf
 * @returns
 */
export declare function createReplaceIx(merkleTree: PublicKey, authority: PublicKey, newLeaf: Buffer, proof: MerkleTreeProof): TransactionInstruction;
/**
 * Helper function for {@link createAppendInstruction}
 * @param merkleTree
 * @param authority
 * @param newLeaf
 * @returns
 */
export declare function createAppendIx(merkleTree: PublicKey, authority: PublicKey, newLeaf: Buffer | ArrayLike<number>): TransactionInstruction;
/**
 * Helper function for {@link createTransferAuthorityIx}
 * @param merkleTree
 * @param authority
 * @param newAuthority
 * @returns
 */
export declare function createTransferAuthorityIx(merkleTree: PublicKey, authority: PublicKey, newAuthority: PublicKey): TransactionInstruction;
/**
 * Helper function for {@link createVerifyLeafInstruction}
 * @param merkleTree
 * @param proof
 * @returns
 */
export declare function createVerifyLeafIx(merkleTree: PublicKey, proof: MerkleTreeProof): TransactionInstruction;
/**
 * Helper function for creating the {@link ConcurrentMerkleTreeAccount}.
 * It is best to use this method to initialize a {@link ConcurrentMerkleTreeAccount}
 * because these accounts can be quite large, and over the limit for what you
 * can allocate via CPI.
 * @param connection
 * @param merkleTree
 * @param payer
 * @param depthSizePair
 * @param canopyDepth
 * @returns
 */
export declare function createAllocTreeIx(connection: Connection, merkleTree: PublicKey, payer: PublicKey, depthSizePair: ValidDepthSizePair, canopyDepth: number): Promise<TransactionInstruction>;
/**
 * Helper function for {@link createCloseEmptyTreeInstruction}.
 * @param merkleTree
 * @param authority
 * @param recipient
 * @returns
 */
export declare function createCloseEmptyTreeIx(merkleTree: PublicKey, authority: PublicKey, recipient: PublicKey): TransactionInstruction;
//# sourceMappingURL=index.d.ts.map